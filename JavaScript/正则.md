## 1. 修饰符

包括i、g、m、s、U、x、a、D、e 等 

| 修饰符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| i      | 不区分大小写                                                 |
| g      | 全局匹配 <br />不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回<br /> 如果带g，则字符串从左到右，找到每个符合条件的都记录下来，直到字符串结尾位置 |
| m      | 多(more)行匹配 <br /> 默认匹配单行，添加m之后实现多行，每个换行符之后就是开始 <br /> 若存在换行\n并且有开始^或结束$符的情况下，和g一起使用实现全局匹配, |
| s      | 特殊字符圆点  .包含换行符 <br /> 默认的圆点 . 是 匹配除换行符 \n 之外的任何单字符，加上s之后, . 中包含换行符 |
| U      | 匹配最近的一个字符串;不重复匹配;                             |
| x      | 将模式中的空白忽略                                           |
| a      | 强制从目标字符串开头匹配;   如果使用$限制结尾字符,则不允许结尾有换行; |
| e      | 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行; |

## 2. 限定符

| 限定符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| *      | 匹配前面的子表达式零次或多次                                 |
| +      | 匹配前面的子表达式一次或多次                                 |
| ?      | 匹配前面的子表达式零次或一次                                 |
| {n}    | n 是一个非负整数，匹配确定的 n 次                            |
| {n,}   | n 是一个非负整数，至少匹配n 次                               |
| {n,m}  | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次 |

>  注意： *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 

如：

```js
'<H1>Chapter 1 - 介绍正则表达式</H1>'
```

当正则为贪婪的：/<.*>/ 

- 匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容 

当正则为非贪婪的：/<.*?>/ 

- 只匹配 <H1> 



## 3. 特殊字符



| 特殊字符 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| ( )      | 标记一个子表达式的开始和结束位置                             |
| \|       | 指明两项之间的一个选择                                       |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 |



## 4. 定位符 

| 定位符 | 作用                                 |
| ------ | ------------------------------------ |
| $      | 匹配输入字符串的结尾位置             |
| ^      | 匹配输入字符串的开始位置             |
| \b     | 匹配一个单词边界，即字与空格间的位置 |
| \B     | 非单词边界匹配                       |

## 5. 预定义类 

| 预定义类 | 作用                                                   |
| -------- | ------------------------------------------------------ |
| .        | 匹配除回车符换行符 \n 之外的任何单字符 等价于\[^\r\n\] |
| [^]      | 匹配任意字符                                           |
| \d       | 数字字符                                               |
| \D       | 非数字字符                                             |
| \s       | 空白符                                                 |
| \S       | 非空白符                                               |
| \w       | 单词字符（字母，数字，下划线），等价于[a-zA-Z_0-9]     |
| \W       | 非单词字符 等价于\[^a-zA-Z_0-9\]                       |

## 6. 范围类 

| 范围类 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| []     | 匹配中括号中的任意内容；如[a-zA-Z]，如果需要匹配-，则将-放在后面[a-z-] |

## 7. 分组 

| 分组 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ()   | 可以使后面的两次直接作用于整个分组，可以用$1,$2,...获取所有分组的内容(反向分组) |
| ?:   | 如果想忽略分组，即不希望捕获某些分组，只需在分组内加上 ?:    |

```js
'2015-09-08'.replace( /(\d{4})-(\d{2})-(\d{2})/g , '$1/$2/$3')
'2015-09-08'.replace( /(\d{4})-(\d{2})-(?:\d{2})/g , '$1/$2')
```



## 8. 对象属性 

| 属性        | 作用                                       |
| ----------- | ------------------------------------------ |
| global      | 是否全文搜索 默认false                     |
| ignore case | 是否大小写敏感，默认false                  |
| multiline   | 多行搜索，默认false                        |
| lastIndex   | 当前表达式匹配内容的最后一个字符的下一位置 |
| suorce      | 正则表达式的文本字符串                     |

```js
/abc/ig.source 
// 'abc'
```



## 9. 方法 

| 方法             | 作用                                                         | 匹配          | 未匹配 |
| ---------------- | ------------------------------------------------------------ | ------------- | ------ |
| 正则.test(str)   | 返回是否有匹配的子串                                         | true          | false  |
| 正则.exec(str)   | 查找并返回当前的匹配结果<br />每次只返回一个从lastIndex开始匹配的结果<br />如果加了/g lastIndex会更新到上一次匹配结束的下一位置，如果没有加，lastIndex不会更新 | 数组          | null   |
| str.search(正则) | 返回是否有匹配的子串                                         | 匹配中的index | -1     |
| str.match(正则)  | 查找并返回当前的匹配结果                                     | 数组          | null   |

> match 这个方法有点像 exec，但：exec 是 RegExp 对象的方法；math 是 String 对象的方法。
>
> 二者还有一个不同点，就是对参数 g 的解释。 如果指定了参数 g，那么 match 一次返回所有的结果。 

```js
var str = "1a1b1c";
var reg = new RegExp("1.", "");
reg.exec(str)		// ["1a", index: 0, input: "1a1b1c", groups: undefined]
reg.exec(str)		// ["1a", index: 0, input: "1a1b1c", groups: undefined]

var str = "1a1b1c";
var reg = new RegExp("1.", "g");
reg.exec(str)		// ["1a", index: 0, input: "1a1b1c", groups: undefined]
reg.exec(str)		// ["1b", index: 2, input: "1a1b1c", groups: undefined]


var str = "1a1b1c";
var reg = new RegExp("1.", "");   
str.match(reg)			// ["1a", index: 0, input: "1a1b1c", groups: undefined]

var str = "1a1b1c";
var reg = new RegExp("1.", "g");
str.match(reg)			// ["1a", "1b", "1c"]
```

## 10. 前瞻

先行断言：x只有在y前面才匹配，必须写成 `/x(?=y)/ `的形式。

先行否定断言： x 只有不在 y 前面才匹配，必须写成` /x(?!y )/` 的形式

```js
let s1 = /\d+(?=%)/g;
let s2 = /\d+(?!%)/g;
s1.exec('100% of US 20 lala 30% of 40');   // [100]
s1.exec('100% of US 20 lala 30% of 40');   // [30]
s2.exec('100% of US 20 lala 30% of 40');   // [10]
```



## 11. 应用

### 11.1 字符串改为驼峰式

```js
str.replace(/-([a-z])/g, function (match, p1, index, input) {
    return p1.toUpperCase();
})
```



