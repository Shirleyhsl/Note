
## 行为型设计模式
### 状态模式
* 定义
    * 当一个对象内部的状态发生改变时，会导致其行为发生变化，这看起来像是改变的对象
* 核心
    * 通过对状态的控制来决定表现行为，所以状态之间是不可相互替换的。
* 作用
    * 解决程序中臃肿的分支判断语句问题，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有分支。在程序中到底产出哪种行为结果，取决于选择哪种状态，而选择何种状态又是程序运行决定的。当然状态模式的最终目的即是`简化分支判断流程`。
* 场景
    * 超级玛丽游戏。将角色的动作包装成状态对象。每次更改状态，触发相应的函数。
### 策略模式
* 定义
    * 将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定的独立性，不会随客户端变化而变化。
* 核心
    * 算法。由于每种算法要处理的业务逻辑相同，因此他们可以相互替换。
* 作用
    * 策略模式使得算法脱离与模块逻辑而独立管理，使我们可以专心研发算法，而不必要受模块逻辑所约束。对于一个复杂的模块开发往往会受到很多限制。
* 优点
    * 策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复利用，提高了算法的复用率。
    * 策略模式与继承相比，在类的继承中，类的方法是被封装在类中，因此当需求很多的算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起，不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。第三，同状态模式一样，策略模式也是一种优化分支判断语句的模式，采用策略模式对算法封装使得算法更利于维护。
* 缺点
    * 由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现。这就增加可用户对策略对象的使用成本。
    * 由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这会造成一些资源的浪费。
* 场景
    * 商品促销。将促销的方案包装成策略对象
    * 表单验证。将表单不同的验证方案（如电话，身份证）包装成策略对象。

* 策略模式和状态模式的异同点
    * 从结构上，两者很像，也是在内部封装一个对象，然后通过返回接口对象实现对内部对象的调用，不同点是，策略对象不需要管理状态、状态之间没有依赖关系、策略之间可以相互替换。在策略对象内部保存的是相互独立的一些算法。 