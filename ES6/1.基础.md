<!-- TOC -->

- [1. 简介](#1-简介)
  - [1.1 ES6含义](#11-es6含义)
  - [1.2 浏览器支持度](#12-浏览器支持度)
- [2. Babel转码器](#2-babel转码器)
  - [2.1 配置.babelrc](#21-配置babelrc)
    - [2.1.1 基本格式](#211-基本格式)
    - [2.1.2 presets字段](#212-presets字段)
    - [2.1.3 plugins字段](#213-plugins字段)
  - [2.2 在webpack中配置babel](#22-在webpack中配置babel)
  - [2.3 浏览器端转换](#23-浏览器端转换)
  - [2.4 在线转换](#24-在线转换)
- [3. Symbol数据类型](#3-symbol数据类型)
  - [3.1 Symbol定义](#31-symbol定义)
  - [3.2 Symbol作为对象属性名](#32-symbol作为对象属性名)
  - [3.3 Symbol使用场景](#33-symbol使用场景)
  - [3.4 Symbol获取](#34-symbol获取)
  - [3.5 使用同一个Symbol值](#35-使用同一个symbol值)
- [4. let和const](#4-let和const)
  - [4.1 let命令](#41-let命令)
    - [4.1.1 基本用法](#411-基本用法)
    - [4.1.2 暂时性死区](#412-暂时性死区)
    - [4.1.3 块级作用域与函数声明](#413-块级作用域与函数声明)
  - [4.2 const命令](#42-const命令)
    - [4.2.1 规则](#421-规则)
    - [4.2.2 本质](#422-本质)
    - [4.2.3 冻结对象freeze](#423-冻结对象freeze)
  - [4.3 对比](#43-对比)
  - [4.4 global对象](#44-global对象)
- [5. 变量的解构赋值](#5-变量的解构赋值)
  - [5.1 数组](#51-数组)
  - [5.2 对象](#52-对象)
  - [5.3 字符串](#53-字符串)
  - [5.4 数值和布尔值](#54-数值和布尔值)
  - [5.5 函数参数的解构赋值](#55-函数参数的解构赋值)
  - [5.6 剩余运算符](#56-剩余运算符)
  - [5.7 用途](#57-用途)
- [6. 字符串的扩展](#6-字符串的扩展)
  - [6.1 字符的Unicode表示方法](#61-字符的unicode表示方法)
  - [6.2 codePointAt()](#62-codepointat)
  - [6.3 fromCodePoint()](#63-fromcodepoint)
  - [6.4 字符串的遍历器接口](#64-字符串的遍历器接口)
  - [6.5 at()](#65-at)
  - [6.6 normalize()](#66-normalize)
  - [6.7 includes(), startsWith(), endsWith()](#67-includes-startswith-endswith)
  - [6.8 repeat()](#68-repeat)
  - [6.9 padStart(), padEnd()](#69-padstart-padend)
  - [6.10 模板字符串](#610-模板字符串)
  - [6.11 标签模板](#611-标签模板)
  - [6.12 String.raw()](#612-stringraw)
- [7. 正则的扩展](#7-正则的扩展)
  - [7.1 RegExp 构造函数](#71-regexp-构造函数)
  - [7.2 宇待串的正则方法](#72-宇待串的正则方法)
  - [7.3 u修饰符](#73-u修饰符)
    - [7.3.1 简介](#731-简介)
    - [7.3.2 检测是否支持u修饰符](#732-检测是否支持u修饰符)
    - [7.3.3 字符串长度函数](#733-字符串长度函数)
  - [7.4 y修饰符](#74-y修饰符)
  - [7.5 sticky 属性](#75-sticky-属性)
  - [7.6  flags 属性](#76--flags-属性)
  - [7.7 s 修饰符](#77-s-修饰符)
  - [7.8 后行断言](#78-后行断言)
- [8. 数值的扩展](#8-数值的扩展)
  - [8.2 Number.isFinite(), Number.isNaN()](#82-numberisfinite-numberisnan)
  - [8.3 Number.parselnt(), Number.parseFloat()](#83-numberparselnt-numberparsefloat)
  - [8.4 Number.islnteger()](#84-numberislnteger)
  - [8.5 Number.EPSILON](#85-numberepsilon)
  - [8.6 安全整数和 Number. isSafelnteger()](#86-安全整数和-number-issafelnteger)
  - [8.7 Math 对象的扩展](#87-math-对象的扩展)
    - [8.7.1 基本函数方法](#871-基本函数方法)
    - [8.7.2 双曲函数方法](#872-双曲函数方法)
    - [8.7.3 指数运算符](#873-指数运算符)
    - [8.7.4 Integer 数据类型](#874-integer-数据类型)
- [9. 函数的扩展](#9-函数的扩展)
  - [9.1 函数参数的默认值](#91-函数参数的默认值)
  - [9.2 rest 参数](#92-rest-参数)
  - [9.3  严格模式](#93--严格模式)
  - [9.4 name 属性](#94-name-属性)
  - [9.5 箭头函数](#95-箭头函数)
  - [9.6 绑定this](#96-绑定this)
  - [9.7 尾调用](#97-尾调用)
    - [9.7.1 介绍](#971-介绍)
    - [9.7.2 优化](#972-优化)
    - [9.7.3 尾递归](#973-尾递归)
- [10. 数组的扩展](#10-数组的扩展)
  - [10.1 扩展运算待](#101-扩展运算待)
    - [10.1.1 替代apply方法](#1011-替代apply方法)
    - [10.1.2 应用](#1012-应用)
    - [10.1.3 实现 Iterator 接口](#1013-实现-iterator-接口)
  - [10.2 Array.from()](#102-arrayfrom)
  - [10.3 Array.of()](#103-arrayof)
  - [10.4 copyWithin()](#104-copywithin)
  - [10.5 find() 和 findIndex()](#105-find-和-findindex)
  - [10.6 fill()](#106-fill)
  - [10.7 entries(), keys() 和 values()](#107-entries-keys-和-values)
  - [10.8 includes()](#108-includes)
  - [10.9 数组的空位](#109-数组的空位)
- [11. 对象的扩展](#11-对象的扩展)
  - [11.1 属性简写](#111-属性简写)
  - [11.2 属性名表达式](#112-属性名表达式)
  - [11.3 方法的 name 属性](#113-方法的-name-属性)
  - [11.4 Object.is()](#114-objectis)
  - [10.5 Object.assign()](#105-objectassign)
    - [10.5.1 基本用法](#1051-基本用法)
  - [](#)
    - [10.5.2 注意点](#1052-注意点)
    - [10.5.3 用途](#1053-用途)
  - [10.6 属性的可枚举性](#106-属性的可枚举性)
  - [10.7 属性的遍历](#107-属性的遍历)
  - [10.8  \_\_proto\_\_](#108--\_\_proto\_\_)
  - [10.9 Object .setPrototypeOf()](#109-object-setprototypeof)
  - [10.10 Object .getPrototypeOf()](#1010-object-getprototypeof)
  - [10.11 entries(), keys() 和 values()](#1011-entries-keys-和-values)
  - [10.12 对象的扩展运算待](#1012-对象的扩展运算待)
  - [10.13 Object.getOwnPropertyDescriptor()](#1013-objectgetownpropertydescriptor)
- [11. Set和Map](#11-set和map)
  - [11.1 Set](#111-set)
    - [11.1.1 基本介绍](#1111-基本介绍)
    - [11.1.2 操作方法](#1112-操作方法)
    - [11.1.3 遍历方法](#1113-遍历方法)
    - [11.1.4 应用](#1114-应用)
    - [11.1.4 转数组](#1114-转数组)
  - [11.2 WeakSet](#112-weakset)
    - [11.2.1 基本介绍](#1121-基本介绍)
    - [11.2.2 操作方法](#1122-操作方法)
    - [11.2.3 不可遍历](#1123-不可遍历)
    - [11.2.4 应用](#1124-应用)
  - [11.3](#113)
    - [11.3.1 基本介绍](#1131-基本介绍)
    - [11.3.2 操作方法](#1132-操作方法)
    - [11.3.3 遍历方法](#1133-遍历方法)
    - [11.3.4 Map转数组](#1134-map转数组)
    - [11.3.5 数组转Map](#1135-数组转map)
    - [11.3.6 Map转对象](#1136-map转对象)
    - [11.3.7 对象转Map](#1137-对象转map)
    - [11.3.8 JSON转Map](#1138-json转map)
  - [11.4 WeakMap](#114-weakmap)
    - [11.4.1 基本介绍](#1141-基本介绍)
    - [11.4.2 操作方法](#1142-操作方法)
    - [11.4.4 应用](#1144-应用)

<!-- /TOC -->
## 1. 简介

### 1.1 ES6含义

ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。

ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版本以后的 JavaScript 的下一代标准，涵盖了 ES2015 、 ES2016 、 ES2017 等，而 ES2015 则是正式名称，特指当年发布的正式版本的语言标准 。 

### 1.2 浏览器支持度

浏览器对于ES6的支持度可以查看网址<http://kangax.github.io/compat-table/es6/> 。随着时间的推移，支持度已经越来越高，超过90%的ES6语法的特性都实现了。Node 是 JavaScript 语言的服务器运行环境（ runtime ），它对 ES6 的支持度更高。

可以通过ES-Checker检查各种运行环境对ES6的支持情况

- `npm install -g es-checker`

- `es-checker`

  =========================================
  Passes 38 feature Detections

  Your runtime supports 90% of ECMAScript 6

  =========================================

  

## 2. Babel转码器

Babel是一个广为使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而 在浏览器或其他环境执行 。 这意味着，可以用 ES6 的方式编写程序，而不用担心现有环境是否支持。

### 2.1 配置.babelrc

使用Bable需要配置文件.babelrc，存放在项目的根目录下。该文件用于设置转码规则和插件。

#### 2.1.1 基本格式

```js
{
    "presets": [],
    "plugins": []
}
```

- presets：设置转码规则
- plugins：告诉babel要使用哪些插件，这些插件可以控制如何转换代码

#### 2.1.2 presets字段

presets字段设定转码规则，告诉babel要转换的源码使用了哪些新的语法特性

- 最新转码规则

  ```shell
  npm install --save-dev babel-preset-latest // 支持现有所有ECMAScript版本的新特性
  // 其它还有
  npm install --save-dev babel-preset-es2015 // 将es6代码编译为es5
  npm install --save-dev babel-preset-es2016 // 将es7代码编译为es6
  npm install --save-dev babel-preset-es2017 // 将es8代码编译为es7
  ```

- 根据目标环境选择不支持的新特性来转译，功能类似于babel-preset-latest

  ```shell
  npm install --save-dev babel-preset-env
  ```

  babel-preset-env中的配置项

  - **targets: {[string]: number | string }**, 默认为{};

    含义是支持一个运行环境的对象，比如支持node版本；可以如下配置： node: '6.0'; 运行环境: chrome, opera, edge, firefox, safari, ie, ios, android, node, electron 

  - **targets.browsers <Array | string>** 

    支持浏览器的配置项，该配置项使用方式可以到 browserslist来查询[https://github.com/browserslist/browserslist](https://github.com/browserslist/browserslist)

  - **modules**，默认值为commonjs

    该参数的含义是：启用将ES6模块语法转换为另一种模块类型。将该设置为false就不会转换模块。该值可以有如下： 'amd' | 'umd' | 'systemjs' | 'commonjs' | false 

    现在通常设置为false，因为以前我们需要使用babel来将ES6的模块语法转换为AMD, CommonJS，UMD之类的模块化标准语法，但是现在webpack都帮我做了这件事了，所以我们不需要babel来做，因此需要在babel配置项中设置modules为false，因为它默认值是commonjs, 否则的话，会产生冲突。 

  - **loose**, 该参数值默认为false

     含义是：允许它们为这个 preset 的任何插件启用”loose” 转换。 

  -  **include: 包含一些插件** ，默认为 []

    比如包含箭头函数，可以如下配置： 

    ```js
    {
      "presets": [
        ["env", {
          "targets": {
            "browsers": ["last 2 versions", "safari >= 7"]
          },
          "include": ["transform-es2015-arrow-functions", "es6.map"]
        }]
      ]
    }
    ```

  - **exclude： 排除哪些插件** ，默认为 []

    比如 排除生成器，可以如下配置： 

- react 转码规则

  ```shell
  npm install --save-dev babel-preset-react
  ```

- 不同阶段语法提案的转码规则（共4个阶段），选装一个

  ```shell
  npm install --save-dev babel-preset-stage-0
  npm install --save-dev babel-preset-stage-1
  npm install --save-dev babel-preset-stage-2
  npm install --save-dev babel-preset-stage-3
  ```

  以上每种预设都依赖于紧随的后期阶段预设，数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。因此 stage-0包含stage-1/2/3的内容。所以如果我们不知道需要哪个stage-x的话，直接引入stage-0就好了。 

- 将这些规则加入.babelrc中

  ```js
  {
      "preset": [
          ['env', {
        		'target': {
          		'browsers': '> 5%' // 支持市场份额超过5%的浏览器
        		}
      	}],
          "stage-2"
       ],
       "plugins":[]
  }
  ```

#### 2.1.3 plugins字段

Babel 默认只转换新的 Java Script 句法（ s yntax ），而不转换新的 API ，如 Iterator 、Generator 、 Set 、 Maps 、 Proxy 、 Reflect 、 Symbol 、 Promise 等全局对象，以及一些定义在全局对象上的方法（如 Object . assign ）都不会转码。举例来说， ES6 在 Array 对象上新增了 Array . from 方法， Babel 就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill 为当前环境提供一个垫片。

- babel-polyfill

  在运行环境中并没有实现的一些方法，babel-polyfill会做兼容

- babel-runtime

  它是将es6编译成es5去执行。我们使用es6的语法来编写，最终会通过babel-runtime编译成es5。也就是说，不管浏览器是否支持ES6，只要是ES6的语法，它都会进行转码成ES5，所以就有很多冗余的代码。 

- babel-plugin-transform-runtime

  虽然 babel-runtime 可以解决 babel-polyfill中的避免污染全局对象，但是它自己也有缺点的。比如，如果我现在有100个文件甚至更多的话，难道我们需要一个个文件加import Promise from 'babel-runtime/core-js/promise' 吗？那这样肯定是不行的，因此这个时候出来一个 叫 `babel-plugin-transform-runtime`， 它就可以帮助我们去避免手动引入 import的痛苦，并且它还做了公用方法的抽离。比如说我们有100个模块都使用promise，但是promise的polyfill仅仅存在1份。 

- 然后，在plugins中配置

  ```js
  {
    'plugins': [
      [
        'transform-runtime', 
        {
          'helpers': false,
          'polyfill': false,
          'regenerator': true,
          'moduleName': 'babel-runtime'
        }
      ]
    ]
  }
  ```

  - **helpers: 默认值为true，**表示是否开启内联的babel helpers(即babel或者环境本来存在的某些对象方法函数)如：extends，etc这样的在调用模块名字时将被替换名字。
  - **polyfill：默认值为true**，表示是否把内置的东西(Promise, Set, Map)等转换成非全局污染。
  - **regenerator：默认值为true，**是否开启generator函数转换成使用regenerator runtime来避免污染全局域。
  - **moduleName：默认值为 babel-runtime，**当调用辅助设置模块（module）名字/路径.

### 2.2 在webpack中配置babel

在webpack中需要安装loader去转换，在安装babel-loader之前，需要安装babel-core，因为babel-core是Babel编译器的核心，因此也就意味着如果需要使用babel-loader进行es6转码的话，需要先安装babel-core

1. 安装`babel-core`

   ```shell
   npm install --save-dev babel-core
   ```

2. 安装`babel-loader`

   ```shell
   npm install --save-dev babel-loader
   ```

3. 按需按照 `babel-preset-env`, `babel-plugin-transform-runtime`, `babel-preset-stage-2 `

   ```shell
   npm install --save-dev  babel-preset-env babel-plugin-transform-runtime babel-preset-stage-2
   ```

4. 配置.babelrc

   ```js
   {
     "plugins": [
        [
         "transform-runtime",
         {
           "polyfill": false
         }
        ]
      ],
      "presets": [
        [
          "env",
          {
            "modules": false
          }
        ],
        "stage-2"
     ]
   }
   ```

5. 在wepack中添加babel-loader配置

   ```js
   module.exports = {
     module: {
       rules: [
         {
           test: /\.js$/,
           exclude: /(node_modules)/, // 排除文件
           loader: 'babel-loader'
         }
       ]
     }
   }
   ```

   

### 2.3 浏览器端转换

以下命令将代码打包成浏览器可以使用的脚本，以 Babel 配合 Browserify 为例。

1. 首先，安装 babelify 模块

   ```shell
   npm install --save-dev babelify babel-preset-latest 
   ```

2. 用命令行转换 ES6 脚本

   此时转换后的代码输出到bundle.js中

   ```shell
    browserify script.js -o bundle.js -t [babelify --presets [ latest ]]
   ```

3. 在 package . json 中添加下面的代码，则不必每次都输入参数 

   ```js
   { 
       "browserify": {
           "transform": [
             ["babelify", {
               "presets": ["latest"]
             }]
           ]
         }
   }
   ```

### 2.4 在线转换

Babel 提供一个 REPL 在线编译器（babeljs.io/repl/)，可以在线将 ES6 代码转为 ES5 代码。
转换后的代码可以直接作为 ES5 代码插入网页井运行。



## 3. Symbol数据类型

ES6引入一种新的原始数据类型为 Symbol ，表示为 独一无二 的值，用来定义独一无二的对象属性名。
### 3.1 Symbol定义
- 一种Symbol类型可以通过使用Symbol()函数来生成

- Symbol()函数可以接受一个字符串作为参数

- 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。

    ```js
    let s1 = Symbol('web');
    let s2 = Symbol('web');
    console.log(s1 === s2);		// false
    console.log(typeof s1);		// symbol
    console.log(typeof s2);		// symbol
    
    const obj = { 
    	toString() { 
    		return 'abc'
        }
    }
    const sym = Symbol(obj); 
    sym // Symbol(abc) 
    ```
    Symbol 值不能与其他类型的值进行运算，否则会报错 。

    ```js
    var sym =Symbol ('My symbol'); 
    "your symbol is" + sym 		// 报错
    ```

    Symbol 值可以显式转为字符串，布尔值，但是不能转为数值 。

    ```js
    var sym = Symbol ('my symbol') ; 
    String(sym) 		// 'Symbol (my symbol)'
    sym.toString() 		// 'Symbol (my symbol)'
    
    var sym =Symbol(); 
    Boolean(sym) 		 // true 
    !sym 				// false 
    ```

    
### 3.2 Symbol作为对象属性名
Symbol可以通过三种方式作为对象属性名
> Symbol的值作为对象属性名，是不能用点运算符的。
- 第一种
    ```js
    // 示例代码
    let symbol = Symbol()
    let a = {}
    a[symbol] = 'web'
    ```
    由代码可知：首先声明了一个Symbol类型的变量symbol，一个空的对象为a，通过a[symbol]给a对象赋值一个web的字符串。表示symbol作为对象属性名，web作为它的属性值。

- 第二种
    ```js
    // 示例代码
    let symbol = Symbol()
    let a = {
        [symbol]:'web'
    }
    ```
    由代码可知：首先声明了一个Symbol类型的变量symbol，接着在声明对象a的同时通过[symbol]给a对象性赋值为web的字符串。

- 第三种
    ```js
    // 示例代码
    let symbol = Symbol()
    let a = {}
    Object.defineProperty(a, symbol, {value: 'web'})
    ```
      由代码可知：首先声明了一个Symbol类型的变量symbol，一个空对象为a，通过Object.defineProperty()方法给a对象赋值为web的字符串。

### 3.3 Symbol使用场景
一种有两种使用场景：
1. 因为Symbol的值是均不相等的，所以Symbol类型的值作为对象属性名，不会出现重复。

2. 代码形成强耦合的某一个具体的字符串。字符串形成“强耦合”，不利于将来的修改和维护。

   ```js
   function getArea(shape , options) { 
   	var area = O; 
   	switch (shape) { 
           case 'Triangle': // 魔术字符串
   			area = . 5 * options.width * optio 口 s.height;
   			break; 
   		// ...
       }
   	return area ;
   }
   
   getArea ( 'Triangle', { width : 100 , height: 100 }); // 魔术字符串
   ```

   上面的代码中，字符串 ’ Triangle ’ 就是一个魔术字符串 。 它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。改进如下：

   ```js
   var shapeType = { 
   	triangle : 'Triangle' 
   }
   function getArea(shape , options) { 
   	var area = 0 ; 
   	switch (shape) { 
           case shapeType.triangle:
   			area = .5 * options.width * options . height ; 
   			break; 
             // ...
   	}
       return area ;
   }
   ```

   如果仔细分析，可以发现 shapeType . triangle 等于哪个值并不重要，只要确保不会和其他 shapeType 属性的值冲突即可。因此，这里就很适合改用 Symbol 值。

   ```js
   const shapeType = { 
   	triangle : Symbol()
   }
   ```

   

### 3.4 Symbol获取
通过`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有Symbols属性名。



### 3.5 使用同一个Symbol值

有时，我们希望重新使用同一个 Symbol 值， Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个Symbol 值，否则就新建井返回 一个 以该字符串为名称的 Symbol 值。

Symbol.for （）不会在每次调用时都返回 一个新的Symbol 类型的值，而是会先检查给定的 key 是否己经存在，如果不存在才会新建一个值。 比如，如果调用 Symbol .for( ” cat ”) 30 次，每次都会返回同 一 个 Symbol 值，但是调用Symbol(” cat ”) 30 次则会返回到个不同的 Symbol 值。

```js
var sl = Symbol.for('foo'); 
var s2 = Symbol.for('foo'); 

sl === s2 // true 
```

Symbol.keyFor 方法返回一个**己登记**的 Symbol 类型值的 key 。

```js
var s1 = Symbol.for('foo')；
Symbol.keyFor(s1) 			// 'foo'

var s2 = Symbol('foo')；
Symbol.keyFor(s2) 			// defined
```



## 4. let和const
### 4.1 let命令 

#### 4.1.1 基本用法

 let命令所在的代码块内有效，有一个块级作用域范围。

> 为什么需要块级作用域？

- 场景一是内层变量可能会覆盖外层变量。
- 场景二是在if或者是for循环中声明的变量会泄漏成为全局变量。

> for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```js
for (let i = O; i < 3; i++) { 
    let i＝ 'abc'；
    console.log(i);
}
// abc
// abc 
// abc 
```

#### 4.1.2 暂时性死区

只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（ binding ）这个区域，不再受外部的影响。

“暂时性死区”（ temporal dead zone ，TDZ ）：在代码块内使用 let 命令声明变量之前，该变量都是不可用的。

```js
if (true) { 
	// TDZ 开始
	tmp = 'abc'; // ReferenceError 
	console.log(tmp); // ReferenceError 

	let tmp; // TDZ 结束
	console.log(tmp); // undefined 

	tmp = 123; 
	console.log(tmp); // 123 
}
```

一些比较隐蔽的死区

```js
function bar(x = y, y = 2) { 
	return [x , y] ; 
}
bar(); // 报错

let x = x;  // 报错
```

参数 x 的默认值等于另 一个参数 y ，而此时 y 还没有声明，属于“死区“。

#### 4.1.3 块级作用域与函数声明

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数 。 ES6 规定，在块级作用域之中，函数声明语句的行为类似于 let ，在块级作用域之外不可引用。

```js
function f() {
  console.log('I am outside!');
}

(function () {
  if (false) {
    // 重复声明一次函数 f
    function f() {
      console.log('I am inside!');
    }
  }
  f()
}());
```

- ES5环境中

  这段代码会输出“I am inside!”，因为在if内声明函数f会被提升到函数头部，实际运行的代码如下：

  ```js
  (function () {
      function f() {
        console.log('I am inside!');
      }
      if (false) {}
      f()
  }());
  ```

- ES6环境中

  理论上输出“I am outside!"。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果真的在 ES6 浏览器中运行上面的代码，是会报错的 ， 这是为什么呢？

  原来，如果改变了块级作用域内声明的函数的处理规则， 显然会对旧代码产生很大影响。为了减轻因此产生的不兼容问题，浏览器的实现可以不遵守上面的规定，而有自己的行为方式，具体如下：

  + 允许在块级作用域内声明函数。
  + 函数声明类似于 var ，即会提升到全局作用域或函数作用域的头部。
  + 同时，函数声明还会提升到所在的块级作用域的头部。

  > 上面 3 条规则只对 ES6 的浏览器实现有效，其他，环境的实现不用遵守，仍旧将块级作用域的函数声明当作 let 处理 即可。

  因此在ES6的浏览器中，上述代码等价于：

  ```js
  (function () {
      var f = undefined;
      if (false) {
          function f() {
              console.log('I am inside!');
          }
      }
      f()
  }());
  ```

> 因此，考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式的形式，而不是函数声明。







### 4.2 const命令

#### 4.2.1 规则

+ const声明一个只读的常量。const一旦声明常量，其值不能被改变。
+ const和let只在声明的块级作用域内有效，否则会报错。
+ const命令同样存在暂时性死区，声明的常量只能在声明的位置后面使用。
+ const声明的常量，与let一样不可重复声明。

#### 4.2.2 本质

const 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值〉而言，值就保存在变量指向的内存地址中，因此等同于常量。但对于复合类型的数据（主要是对象和数组）而言，变量指向的内存地址保存的只是一个指针， con st 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制 。 因此，将一个对象声明为常量时必须非常小心。

#### 4.2.3 冻结对象freeze 

如果真的想将对象冻结，应该使用 Object.freeze 方法。

```js
const foo = Object.freeze({}); 


// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foe.prop = 123; 
```

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

```js
let constantize = (obj) => {
    Object.freeze(obj)
    Object.keys(obj).foreach((key) => {
        if(typeof obj[key] === 'object') {
            constantize(obj[key])
        }
    })
}
```



### 4.3 对比

| | var | let | const |
|---|---|---|---|
|用处|定义变量|定义变量|定义变量|
|是否可重复声明|是|否|否|
|是否可修改|是|是|否|
|作用域|没有块级作用域，全局范围有效|块级作用域|块级作用域|
|变量提升|是|否|否|
|初始声明是否需要赋值|否|否|否|
|内存分配| 会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针|不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错|不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性|
- let和const在定义之前是不能被使用的，因为虽然变量也会被提升，但是提前声明的变量都在临时性死区中，不能使用；
- const 和 let 声明的变量不在 window， 无法通过window.xx获取变量
- for循环有个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

### 4.4 global对象

 let 命令、 const 命令、 class 命令声明的全局变量不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性隔离。

ES5 的顶层对象本身也是一个问题，因为它在各种实现中是不统一的。

- 在浏览器中，顶层对象是 window, 但Node 和 Web Worker 没有 window 。
- 在浏览器和 Web Worker 中， self 也指向顶层对象，但是 Node 没有 self 。
- 在 Node 中，顶层对象是 global ，但其他环境都不支持。

同 一段代码为了能够在各种环境中都取到顶层对象，目前一般是使用 this 变量，但是也有局限性。

- 在全局环境中， this 会返回顶层对象。但是，在 Node 模块和 ES6 模块中， this 返回的是当前模块。
- 对于函数中的 this ，如果函数不是作为对象的方法运行，而是单纯作为函数运行， this会指向顶层对象。但是，严格模式下， this 会返回 undefined 。
- 不管是严格模式，还是普通模式， new Function (’ return this ’）（）总会返回全局对象。但是，如果浏览器用了 CSP (Content Security Policy ，内容安全政策），那么eval, new Function 这些方法都可能无法使用。

综上所述，很难找到一种方法可以在所有情况下都取到顶层对象。以下是两种勉强可以使用的方法 。

```js
// 方法一
(typeof window !== 'undefined' ? window 
:(typeof process === 'object' && typeof require === 'function' &&  typeof global === 'object') 
? global : this); 
```

```js
// 方法二
var getGlobal = function () { 
	if (typeof self !== 'undefined') { return self; ) 
	if (typeof window !== 'undefined') { return window; ) 
	if (typeof global !== 'undefined') { return global; ) 
	throw new Error ( 'unable to locate global object'); 
}
```





## 5. 变量的解构赋值
在ES6中可以从数组和对象中提取值，对变量进行赋值，称为解构赋值。

解构赋值就是只要等号两边的模式相同，左边的变量就会被对应赋值。
```js

let [x,y='b'] = ['a'];
console.log(y); // b

let [x,y='b'] = ['a', undefined];
console.log(y); // b

let [x,y='b'] = ['a', null];
console.log(y); // null
```
解构赋值分类：
- 数组的解构赋值
- 对象的解构赋值
- 字符串的解构赋值
- 数字以及布尔值的解构赋值
- 函数参数的解构赋值

解构赋值
- 解构赋值允许指定默认值。
- 在使用默认值的时候，应该注意undefined，因为undefined是不能赋值的。

解构赋值的情况
两种情况：
- 完全解构
- 不完全解构

### 5.1 数组

只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

如果结构不成功，变量的值就等于undefined

```js
let [a = 1, b] = []; 
// a = 1, b = undefined

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4

let [x,, y) = [1, 2, 3]; 
x // 1 
y // 3 

let [x, y, ... z] = ['a']; 
x  // 'a'
y // undefined 
z // [] 
```

如下具有Iterator 接口的也可解构赋值

```js
function* fibs() { 
	let a = O; 
	let b = l; 
	while (true) { 
		yield a; 
		[a, b] = [b, a + b]; 
    }
}

let [first, second, third, fourth, fifth, sixth] = fibs(); 

// 0, 1, 1, 2, 3, 5
```



**默认值**

结构规则：

1. 如果有赋值并不等于undefined，则采用赋值的值
2. 如果有默认值，则采用默认值
3. 等于undefined

ES6 内部使用严格相等运算符 (===）判断一个位直是否有值。 所以，如果一个数组成员不严格等于 undefined ，默认位是不会生效的 。

```js
let [x, y ='b'] = ['a', undefined]; 
// x='a', y='b'

// 需严格等于 undefined 才会使用默认值
let [x = l] = [null]; 
// x = null 

// 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到时才会求值。
function f() { 
	console.log ('aaa'); 
}
let [x = f()] = [1] ; 
// x = 1， 并且不会输出aaa

// 上述代码等价于
let x; 
if([1][0] === undefined) { 
	x = f(); 
} else { 
	x = [1][O]; 
}
```



### 5.2 对象

数组的元素是按次序排列的，变量的取值是由它的位置决定的：而对象的属性没有次序，变量必须与属性同名才能取到正确的值。

```js
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo :'aaa', bar :'bbb'}; 
baz // undefined 

const { log } = console;
log('hello') // hello
```

对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。

```js
let { foo : baz } = { foo : 'aaa', bar : 'bbb'} ; 
baz // 'aaa' 
foo // error: foo is not defined 
```

与数组一样，解构也可以用于嵌套结构的对象。

```js
var node = {
    loc: {
        start : {
            line: 1,
            column: 5
        }
    }
}
var {loc, loc: {start}, loc: {start: {line}}} = node
line // 1
loc // Object {start : Object}
start // Object {line: 1, column: 5}
```

对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于 undefined 。

```js
var { x, y = 5} = { x: 1 } ; 
x // 1 
y // 5 

var { x: y = 3} = { x: 5} ; 
y // 5 

var {x = 3) = {x: undefined}; 
x // 3 
```

如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错 。

```js
let {foo: {bar}} = {baz :'baz' }; // 报错
等号左边对象的 foo 属性对应一个子对象。该子对象的 bar 属性在解构时会报错。 
原因很简单，因为 foo 此时等于 undefined ，再取子属性就会报错。
```

书写

下面代码的写法会报错 ， 因为 JavaScript 引擎会将｛ x } 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JS 将其解释为代码块，才能解决这个问题。

```js
let x; 
{x) = {x : l};  // SyntaxError: syntax error 
 
 // 正确的写法
let x; 
（{x) = {x : l}）; 
```

解构赋值允许等号左边的模式之中不放置任何变量名 。 因此，可以写出非常古怪的赋值表达式 。

```js
// 以下表达式虽然毫无意义，但是语法是合法的，可以执行
({} = [true, false]); 
({}= 'abc'); 
({} =[]); 
```



### 5.3 字符串

字符串的结构赋值，会将字符串转成一个类似数组的对象

```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

类似数组的对象都有一个length属性，因此还可以对这个属性进行结构赋值

```js
let {length : len} = 'hello';
len // 5
```



### 5.4 数值和布尔值

结构赋值时，如果等号右边不是对象或数组，则会转为对象，如果无法转为对象，则对它们进行解构赋值时会报错

```js
let {toString: s} = 123
s === Number.prototype.toString // true

let {toString: s} = true
s === Boolean.prototype.toString // true

上面的代码中，数值和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值。

let {prop: x} = undefined   //TypeError
let {prop: y} = null	//TypeError
```



### 5.5 函数参数的解构赋值

```js
function add([x, y]){
  return x + y;
}
 
add([1, 2]); // 3

[[1,2], [3,4]].map(([a,b]) => a+b)
// [3, 7]
```
函数参数的解构也可以用默认值

```js
function move({x:0, y:0} = {}) {
    return [x, y]
}
move({x: 3, y: 8})  // [3, 8]   传了参数，且参数完整 等价于：{x, y} = {x: 3, y:8}
move({x: 3})        // [3, 0]   传了参数，但参数部分完整 等价于：{x, y:0} = {x: 3}
move({})		   // [0, 0]   传了参数，但参数不完整 等价于：{x:0, y:0} = {}
move()			   // [0, 0]   未传参数，但有默认值 等价于：{x:0, y:0} = {}

解析：函数move参数是一个对象，并且有默认值。通过对这个对象进行解构，得到变量x和y的值。如果结构失败，x和y等于默认值


function move({x, y} = {x:0, y:0}) {
    return [x, y]
}
move({x: 3, y: 8})  // [3, 8]   传了参数，且参数完整 等价于：{x, y} = {x: 3, y:8}
move({x: 3})        // [3, undefined]   传了参数，但参数部分完整 等价于：{x, y} = {x: 3}
move({})		   // [undefined, undefined]   传了参数，但参数不完整 等价于：{x, y} = {}
move()			   // [0, 0]   未传参数，但有默认值 等价于：{x, y} = {x:0, y:0}
```



### 5.6 剩余运算符

```js
let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};
// a = 10
// b = 20
// rest = {c: 30, d: 40}
```
计算函数任意个参数之和：
```js
function sum(...num){
    var sumNum = 0;
    for(let i=0; i<num.length; i++){
        sumNum += parseInt(num[i])
    }
    console.log(sumNum)
}
```



### 5.7 用途

1. 交换变量的值

   ```js
   let x = 1; 
   let y = 2 ; 
   [x, y] = [y , x]; 
   ```

2. 从函数返回多个值

   ```js
   function example() { 
   	return [1, 2, 3]   
   }
   let [a, b, c] = example() ; 
   ```

3. 函数参数的定义

   ```js
   function f({x, y, z}) { ... } 
   f({z: 3, y: 2, x: 1}) 
   ```

4. 提取JSON数据

   ```js
   let jsonData = { 
   	id: 42, 
   	data: [867, 5309]
   }
   let { id, data: number } = josnData;
   id // 42
   number // [867, 5309]
   ```

5. 函数参数的默认值

   ```js
   jQuery.ajax = function (url, { 
   	async = true, 
   	beforeSend = function () { } , 
   	cache = true, 
   	complete= function () {}, 
   	crossDomain = false, 
   	global = true, 
   	// ... more config 
   }) 
   ```

6. 遍历Map结构

   任何部署了 Iterator 接口的对象都可以用 for ... of 循环遍历。 Map 结构原生支持 Iterator接口，配合变量的解构赋值获取键名和键值就非常方便。

   ```js
   var map= new Map(); 
   map.set ('first', 'hello') ; 
   map.set ('second', 'world'); 
   
   for (let [key, value) of map) { 
   	console.log(key +' is '+ value); 
   }
   // first is hello 
   // second is world 
             
   // 只获取键名
   for (let [key] of map) {
       // ....
   }
   
   // 只获取键值
   for (let [,value] of map) {
       // ...
   }
   ```

7. 输入模块的指定方法

   加载模块时，往往需要指定输入的方法。解构赋值使得输入语句非常清晰 。
   const ( SourceMapConsumer, SourceNode } = require (“source-map"); 





## 6. 字符串的扩展

### 6.1 字符的Unicode表示方法

JS中允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。这表明这种表示法只限于\u0000-\uFFFF之间的字符。超过这个范围的字符，ES5将无法识别，而必须用2个双字节的形式表示。

在ES6中，只需要将码点放入大括号，就能正确解读该字符。

```js
"\u{20BB7}"
// "𠮷"
```

因此，在ES6中共有6中方法可以表示一个字符

```js
'\z' === 'z'  // true
'\122' === 'z' // true
'\x7A' === 'z' // true  16进制
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true  ES6新增
```

### 6.2 codePointAt()

JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4个字节储存的字符（ Unicode 码点大于 0XFFFF的字符 ,  JavaScript 会认为它们是 2 个字符。

ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，**返回一个字符的码点**。对于那些2个字节存储的常规字符，它的返回值与charCodeAt方法相同。

```js
var s ＝"𠮷a"; 
s.codePointAt(0) // 134071 '𠮷'的码点
s.codePointAt(1) // 57271 '𠮷'的后两个字节的码点
s.codePointAt(2) // 97 'a'的码点
```

因此要正确获取“𠮷a”的码点，需要codePointAt(0)和codePointAt(2) 这样的参数显然是不合适的。解决的方法是使用for...of循环

```js
var s ＝"𠮷a"; 
for (let ch of s) {
    console.log(ch.codePointAt(0).toString(16)) // 16进制
}
// 20bb7
// 61
```

检测一个字符占用的编码单元数量，最简单的方法就是调用字符codePointAt()方法 

```js
function is32bit(c) {
    return c.codePointAt(0) > 0xFFFF;
}
console.log(is32bit('𠮷')); // true
console.log(is32bit('a')); // false
```

### 6.3 fromCodePoint()

ES5 提供了 String.fromCharCode 方法，用于**从码点返回对应字符**，但是这个方法不能识别 32 位的 UTF- 16 字符。ES6 提供了 String . fromCodePoint 方法，可以识别大于 OxFFFF 的字符。在作用上，正好与 codePointAt 方法相反。

```js
console.log(String.fromCodePoint(134071)); // 𠮷

// 如果 String.fromCodePoint方法有多个参数 ，则它们会被合并成一个字符串返回。
String.fromCodePoint(0x78 , 0x1f680, 0x79) ==='x\uD83D\uDE80y'  // true 

```



### 6.4 字符串的遍历器接口 

ES6 为字符串添加了遍历器接口，使得字符串可以由 for ... of 循环遍历。除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点。

```js
for(let ch of 'foo') {
    console.log(ch)
}
// 'f'
// 'o'
// 'o'
```

### 6.5 at()

ES5： 提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。

ES6：目前有个**提案**提出字符串实例的at方法，可以识别码点大于 0xFFFF 的字符。

```js
'abc'.charAt(0) // 'a'
'𠮷'.charAt(0) // '\uD842' 错误
'𠮷'.at(0) // '\uD842'
```

### 6.6 normalize()

识别带重音符号的字符有两种方式

1. 直接提供重音符号的字符，如\u01D1
2. 提供合成符号，即原字符与重音符号合成一个字符，如\u004F\u030C（\u01D1与\u004F\u030C表示同一个重音符号）

但这两种方式JavaScript 无法识别是同一字符

```js
'\u01D1' === '\u004F\u030C'  // false
// JavaScript 将合成字符视为两个字符，导致两种表示方法不等价 。
'\u01D1'.length  // 1
'\u004F\u030C'.length // 2
```

ES6：提供了 normalize 方法， 用来将宇符的不同表示方法统一为同样的形式，这称为 Unicode 正规化 。

```js
'\u01D1'.normalize() === '\u004F\u030C'.normalize()  // true
```

normalize 方法可 以接受一个参数来指定 normalize 的方式 ， 参数的 4 个可选值如下 

- NFC ， 默认参数 ， 表示“标准等价合成”（ Normalization Form Canonical Composition ) , 返回多个简单字符的合成字符 。 所谓 “ 标准等价”指的是视觉和语义上的等价 。

- NFD ，表示 “ 标准等价分解 ” （ Normalization Form Canonical Decomposition ），即在标准等价的前提下 ，返回合成字符分解出的多个简单字符。

- NFKC , 表示“兼容等价合成 ”（ Normalization Form Compatibility Compos ition ），返回合成字符 。 所谓“兼容等价”指 的 是语义上等价，但视觉上不等价，比如“囍”和 “ 喜喜 ” 。
  （这只是举例 ， normalize 方法并不能识别中文 。）

- NFKD ，表示“兼容等价分解 ” （ Normalization Form Compatibility Decompos ition ），即在兼容等价的前提下，返回合成字符分解出的多个简单字符 。

  ```js
  '\u004F\u030C'.normalize('NFC').length // 1
  '\u004F\u030C'.normalize('NFD').length // 2
  ```

  

因此在对比字符串之前，一定先把他们标准化为同一种形式 

```js
let normalized = values.map(function(text) {
    return text.normalize();
})
```

不过， normalize 方法目 前不能识别 3 个或 3 个 以上字符的合成 。 这种情况下 ，还是只能使用正则表达式 ，通过 Unicode 编号区间判断。



### 6.7 includes(), startsWith(), endsWith()

传统上， JavaScript 中只有 indexOf 方法可用来确定一个字符串是否包含在另 一个字符串中。 ES6 又提供 了 3 种新方法。

- includes () ：返回布尔值，表示是否找到了参数字符串 。
- startsWith()： 返回布尔值 ， 表示参数字符串是否在源字符串的头部 。
- endsWith()：返回布尔值， 表示参数字符串是否在源字符串的尾部 。

这 3 个方法都支持第二个参数 ， includes ()和startsWith()表示开始搜索的位置， endsWith 它表示匹配的子串为前n个字符

```js
var s = 'Hello world!'; 
s.startsWith ('Hello') // true 
s.includes ('Hello', 6) // false 
s.endsWith ( 'Hello', 5) // true  前5个字符是'hello' ，符合以'hello'结尾
```

### 6.8 repeat()

repeat(n) 方法返回一个新字符串

- 如果n是正整数，则将原字符串重复 n 次
- 如果n是小数，会被向下取整，然后重复。
- 如果n是负数或者 Infinity ，会报错。
- 但如果参数是 0 到-1 之间的小数，则等同于 0。
- 如果n是 NaN 等同于 0 。
- 如果 repeat 的参数是字符串 ， 则会先转换成数字 。

```js
'na'.repeat(2.9) // "nana"
'na'.repeat (Infinity)  // RangeError 
'na'.repeat (-1)  // RangeError 
'na'.repeat(-O.6) // ""
'na'.repeat(NaN) // ""
'na'.repeat ('na') // ""
'na'.repeat ('3') // "nanana"
```

### 6.9 padStart(), padEnd()

ES2017 引入了字符串补全长度的功能 。 如果某个字符串不够指定长度，会在头部或尾部补全 。 -

- padStart() ：用于头部补全
- padEnd()： 用于尾部补全 
- 如果原字符串的长度等于或大于指定的最小长度，则返回原字符串 。
- 如果用来补全的字符串与原字符串的长度之和超过了指定的最小长度 , 则会截去超出位数的补全字符串 。
- 第二个参数默认值为空格

```js
'x'.padStart(5, 'ab' ) // 'ababx' 
'x'.padStart(4, 'ab' ) // 'abax' 

'x'.padEnd(5, 'ab' ) // 'xabab' 
'x'.padEnd(4, 'ab' ) // 'xaba' 

'xabc'.padEnd(2, 'ab' ) // 'xabc' 

'abc'.padEnd(5, '0123456' ) // 'abc01' 

'x'.padEnd(4) // 'x   '
```

用途

- 为数值补全指定位数

  ```js
  '12'.padStart(10,'0') // '0000000012' 
  ```

- 提示字符串格式

  ```js
  '12'.padStart(10,'YYYY-MM-DD') // 'YYYY-MM-12' 
  '09-12'.padStart(10,'YYYY-MM-DD') // 'YYYY-09-12' 
  ```

### 6.10 模板字符串

模板字符串（ template string ）是增强版的字符串 ，用反引号（`）标识 。它可 以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。在模板字符串中嵌入变量，需要将变量名写在${}中 。

```js
function fn ( ) { 
	return "Hello World"; 
}

`foo ${fn()} bar`  // foo Hello World bar 
```

如果需要引用模板字符串本身，可以像下面这样写。

```js
// 写法一
let str ='return'＋'`Hello ${name}!`'；
let func = new Function ( 'name', str); 
func ('Jack') // 'Hello Jack !'
```

```js
// 写法二
let str = '(name) ＝＞`Hello $ {name}!`'；
let func = eval.call(null, str); 
func ('Jack') // 'Hello Jack !' 
```



### 6.11 标签模板

标签模板（tagged template）：是函数调用的一种特殊形式，将模板字符串紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。

```js
alert`123`;
// 等价于
alert(123);
```

如果模板字符中有变量，就不再是简单的调用了，而是要将模板字符串先处理成多个参数，再调用函数 。

- 第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分
- 剩余的参数依次为每个变量。

如：以下两个语句互相等价

```js
tag`Hello ${ a + b } world ${ a * b }`；
tag (['Hello', 'world', ''], 15, 50); 
```

案例：

```js
// 展示如何将各个参数按照原来的位置拼接回去。
let total = 30;
let msg = passthru `The total is ${ total } ( ${total*1.05} with tax)`

function passthru(literals) {
    let result = '';
    let i = 0;
    while (i < literals.length) {
        result += literals[i++];
        if (i < arguments.length) {
            result += arguments[i]
        }
    }
    return result
}
```

“标签模板”的应用：

- 过滤 HTML 字符串，防止用户输入恶意内容。

  ```js
  let sender = '<哈哈哈>'
  let message = SaferHTML `<p> ${sender} has sent you a message. </p>`;
  
  function SaferHTML(templateData) {
      var s = templateData[0];
      for (var i = 1; i < arguments.length; i++) {
          var arg = String(arguments[i]);
          s += arg.replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;");
          s += templateData[i];
      }
      return s;
  }
  
  message // <p> &lt;哈哈哈&gt; has sent you a message. </p>
  ```

- 语言转换（国际化处理）

  ```js
  i18n`Welcome to ${ siteName }, you are visitor number ${ visitorNumber } !`
  // "欢迎访问 xxx ，您是第 xx xx 位访问者！"
  ```



### 6.12 String.raw()

返回一个反斜线都被转义（即反斜线前面再加一个反斜线〉的字符串，对应于替换变量后的模板字符串。

```js
String.raw`Hi\n${2 + 3}!`
// "Hi\\n5!"
```

String.raw 方法也可以作为正常的函数使用。这时，其第一个参数应该是一个具有 raw属性的对象，且 raw 属性的值应该是一个数组。

```js
String.raw({ raw : 'test'}, 0, 1, 2) ;  // 't0els2t'
// 等价于
String.raw({ raw: ['t','e','s','t']} , 0, 1, 2) ; 
```



## 7. 正则的扩展

### 7.1 RegExp 构造函数

ES5中通过RegExp声明正则的两种方式

- 包含两个参数：第一个是字符串，第二个是修饰符（ flag ）

  ```js
  var regex = new RegExp('abc', 'i')
  ```

- 包含一个参数：正则表示式，这时会返回一个原有正则表达式的拷贝。

  ```js
  var regex = new RegExp(/abc/i)
  ```

这两种方式都等价于`var regex = /xyz/i; `

但是， ES5 不允许第一个参数使用正则表达式时，同时使用第二个参数添加修饰符，会报错

```js
var regex = new RegExp(/abc/ig,'i'); // Uncaught TypeError: Cannot supply flags
```

ES6：ES6 改变了这种行为 ， 如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有正则表达式的修饰符，只使用新指定的修饰符。

```js
 new RegExp(/abc/ig,'i').flags;  // 'i'
```



### 7.2 宇待串的正则方法

字符串对象共有 4 个方法可以使用正则表达式 ：match()、 replace()、 search()和 split()。

ES6 使这 4 个方法在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法都定义在 RegExp 对象上。

- String.prototype.match 调用 RegExp.prototype[Symbol.match]
- String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
- String.prototype.search调用 RegExp.prototype[Symbol.search]
- String.prototype.split调用 RegExp.prototype[Symbol.split]

### 7.3 u修饰符

#### 7.3.1 简介

ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，可以正确处理 4 个字节的 UTF-16 编码。

```js
let text = '𠮷';  // 4字节
console.log(/^.$/.test(text)); // fasle
console.log(/^.$/u.test(text)); // true
```

ES6 新增了使用大括号表示 Unicode 字符的表示法，这种表示法在正则表达式中必须加上 u修饰符才能识别当中的大括号，否则会被解读为量词。

```js
/\u{61}/.test ('a')  	 // false
/\u{61}/u.test ('a')     // true
/\u{20BB7}/u.test('𠮷')	 // true 
```



#### 7.3.2 检测是否支持u修饰符 

 检测当前引擎是否支持u修饰符 

```js
function hasRegExpU() {
    try {
        var pattern = new RegExp(".","u");
        return true;
    } catch (error) {
        return fasle;
    }
}
```

#### 7.3.3 字符串长度函数

正确返回字符串长度的函数，包括码点大于\uFFFF的。

```js
function codePointLength(text) { 
	var result= text.match(/[\s\S]/gu) ; 
	return result ? result.length : 0 ; 
}

let s = '𠮷𠮷'
s.length // 4
codePointLength(s);  // 2
```

### 7.4 y修饰符

y 修饰符：叫作“粘连“（ sticky ）修饰符。

与g修饰符类似，都是全局匹配，后一次匹配都从上一次匹配的下一个位置开始。不同之处在于g 修饰符只要剩余位置中存在匹配就行，而 y 修饰符会确保匹配必须从**剩余的第一个位置**开始，这也就是“粘连”的涵义。

```js
var s = "aaa_aa_a";
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"] 
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa" ]
r2.exec(s) // null  因为上一次匹配的下一个位置是'_'
```

### 7.5 sticky 属性

与 y 修饰符相匹配， ES6 的正则对象多了 sticky 属性，表示是否设置了 y 修饰符。

```js
var r = /hello\d/y; 
r.sticky // true 
```

### 7.6  flags 属性

ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。

```js
/abc/ig.flags 
// 'gi'
```

### 7.7 s 修饰符

目前还是**提案**

正则表达式中，点(.)是一个特殊字符，代表任意的单个字符，但行终止符（ line terminator character ）除外。

以下 4 个字符属于“行终止符”。

- U+000A 换行符（\n）
- U+000D 回车符（\r）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（ paragraph separator) 

```js
/foo.bar/.test('foo\nbar')  // false
```

如果想任意匹配字符

```js
/foo[^]bar/.test('foo\nbar')  // true
```

这种解决方案毕竟不太符合直觉，所以有如下提案（ github.com/mathiasbynens/es-regexp-dotall-flag ）：引入 /s 修饰符，使得 ．可以匹配任意单个字符。

```js
/foo.bar/s.test('foo\nbar') // true 
```

### 7.8 后行断言

ES5只支持先行断言（ lookahead ），在ES6中**提案**后行断言（ lookbehind ）。

先行断言：x只有在y前面才匹配，必须写成 `/x(?=y)/ `的形式。

先行否定断言： x 只有不在 y 前面才匹配，必须写成` /x(?!y )/` 的形式

```js
let s1 = /\d+(?=%)/g;
let s2 = /\d+(?!%)/g;
s1.exec('100% of US 20 lala 30% of 40');   // [100]
s1.exec('100% of US 20 lala 30% of 40');   // [30]
s2.exec('100% of US 20 lala 30% of 40');   // [10]
```

后行断言：x只有在y后面才匹配，必须写成 `/(?<=y)x/`的形式

后行否定断言：x 只有不在 y 后面才匹配，必须写成` /(?<!y )x/ `的形式

```js
/(?<=$)\d+/.exec('Benjamin Franklin is on the $100 bill ');   // [100]
/(?<!$)\d+/.exec('it is worth about €90');   // [90]
```

“后行断言”的实现需要先匹配`/(?<=y)x/`的 x ， 然后再回到左边匹配 y 的部分。这种“先右后左”的执行顺序与所有其他正则操作相反 ， 导致了一些不符合预期的结果。



## 8. 数值的扩展

 ### 8.1 二进制和八进制表示法

ES6 提供了二进制和八进制数值的新写法，分别用前缀 0b （ 或 0B ）和 0o （或 0O ）表示。

```js
0b111110111 === 503  // true
0o767 === 503 // true
```

ES5：在严格模式中，八进制数值就不再允许使用前缀0表示。 

ES6： 进一步明确，要使用前缀0o（0O）表示。

```js
// 非严格模式
(function() { 
	console.log(0o11 === 011) ; 
})() // true 

// 严格模式
(function () { 
	'use strict' ; 
	console.log (0o11 === 011) ; 
})() 
// Uncaught SyntaxError: Octal literals are not allowed in strict mode. 
```

如果要将使用 0b 和 0x 前缀的字符串数值转为十进制数值，要使用 Number 方法。

```js
Number ('0b111') // 7 
Number ('0o10') // 8 
```

### 8.2 Number.isFinite(), Number.isNaN()

ES6新增

Number.isFinite()：用来检查一个数值是否为有限的（ finite ） 。

```js
Number.isFinite(1); 		// true 
Number.isFinite(0.8); 		// true 
Number.isFinite(NaN); 		// false 
Number.isFinite(Infinity);  // false 
Number.isFinite(-Infinity); // false 
Number.isFinite ('foo'); 	// false 
Number.isFinite ('15'); 	// false 
Number.isFinite(true); 		// false 
```

ES5实现Number.isFinite()

```js
(function (global) { 
	var global isFinite = global.isFinite; 
	Object.defineProperty(Number , 'isFinite', { 
		value : function isFinite(value) { 
			return typeof value === 'number' && global_isFinite(value); 
         },	
		configurable : true , 
		enumerable : false, 
		writable : true 
	}); 
})(this); 
```

Number. isNaN()：用来检查一个值是否为 NaN 。

```js
Number.isNaN(NaN) 		// true 
Number.isNaN(15) 		// false 
Number.isNaN('15') 		// false 
Number.isNaN(true) 		// false 
Number.isNaN(9/NaN) 	// false 
Number.isNaN ('true'/10 ) // true 
Number. isNaN ('true'/'true') // true 
```

ES5实现Number.isNaN()

```js
(function (global) {
    var global_isNaN = global.isNaN; 
	Object.defineProperty (Number, 'isNaN', { 
		value: function isNaN(value) { 
			return typeof value ==='number' && global_isNaN(value); 
         },
         configurable: true, 
		enumerable : false, 
		writable: true 
	}); 
} ) (this);
```

这两个新方法与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用Number()将非数值转为数值，再进行判断，而新方法只对数值有效，对于非数值一律返回false。 Number. isNaN() 只有对于 NaN 才返回 true ，非 NaN 一律返回 false 。

### 8.3 Number.parselnt(), Number.parseFloat() 

```js
// ES5 的写法
parseint('12.34' ) 		// 12 
parseFloat('123.45#') 	// 123.45 

// ES6 的写法
Number.parseInt ('12.34') 	 // 12 
Number.parseFloat('123.45#') // 123.45 
```

这样做的目的是逐步减少全局性方法，使得语言逐步模块化 。

```js
Number.parseInt === parseInt 
Number.parseFloat === parseFloat 
```

### 8.4 Number.islnteger() 

Nurnber.islnteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值 。

```js
Number.isInteger(25) 		// true
Number.isInteger(25.0) 		// true
Number.isInteger(25.1) 		// false
Number.islnteger("15") 		// false
Number.isinteger(true) 		// false
```

ES5 实现Number.islnteger()

```js
(function (global) {
    var floor =Math.floor, 
    var isFinite = global.isFinite; 
	Object.defineProperty (Number, 'isinteger', { 
		value: function isinteger(value) { 
			return typeof value ==='number' && isFinite(value) && floor(value) === value; 
         },
         configurable: true, 
		enumerable : false, 
		writable: true 
	}); 
} ) (this);
```



### 8.5 Number.EPSILON 

ES6 在 Number 对象上面新增一个极小的常量一Number.EPSILON 。

```js
Number.EPSILON  // 2.220446049250313e-16 
Number.EPSILON.toFixed(20) // '0.00000000000000022204'
```

引入一个这么小的量，目的在于为浮点数计算设置一个误差范围。我们知道浮点数计算是不精确的。

```js
0.1 + 0.2 // 0.30000000000000004 
```

但是如果这个误差能够小于 Number .E PSILON ，我们就可以认为得到了正确结果。

```js
function withinErrorMargin (left, right) { 
return Math.abs(left - right) < Number.EPSILON ; 

withinErrorMargin(0.1 + 0.2, 0.3 ) // true 
withinErrorMargin(0.2 + 0.2, 0.3) // false 
```

### 8.6 安全整数和 Number. isSafelnteger() 

JavaScript 能够准确表示的整数范围在－2^53 到 2^53 之间（不含两个端点），超过这个范围就无法精确表示。

```js
Math.pow (2, 53) // 9007199254740992 
9007199254740992 // 9007199254740992 
9007199254740993 // 9007199254740992 
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
```

ES6引入了Number.MAXSAFEINTEGER 和 Number.MINSAFEINTEGER 两个常量，用来表示这个范围的上下限 。

```js
Number.MAXSAFEINTEGER === Math.pow(2, 53) - 1 // true 
Number.MAXSAFEINTEGER === 9007199254740991 // true
Number.MINSAFEINTEGER === -Number.MAXSAFEINTEGER // true 
Number.MINSAFEINTEGER === -9007199254740991 // true 
```

Number.isSafeinteger() 则是用来判断一个整数是否落在这个范围之内 。

```js
Number.isSafeinteger ('a')		// false 
Number.isSafeinteger(null) 		// false 
Number.isSafeinteger(NaN) 		// false 
Number.isSafeinteger(Infinity) 	// false 
Number.isSafeinteger(-Infinity) // false 

Number.isSafeinteger(3) 		// true
Number.isSafeinteger(1.2) 		// false 
Number.isSafeinteger(9007199254740990) // true
Number.isSafeinteger(9007199254740992) // false

Number.isSafeinteger(Number.MINSAFEINTEGER - 1) // false
Number.isSafeinteger(Number.MIN SAFE INTEGER)   // true
Number.isSafeinteger(Number.MAX_SAFE_INTEGER)  // true
Number.isSafeinteger(Number.MAX_SAFE_INTEGER + 1)  // false 
```

函数实现：

```js
Number.isSafeinteger = function (n) { 
	return (typeof n === 'number' && Math.round(n) === n 
            && Number.MINSAFEINTEGER <= n && Number.MAX_SAFE_INTEGER >= n)
}
       
```



### 8.7 Math 对象的扩展

#### 8.7.1 基本函数方法

|                 | 作用                                                         | 备注                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Math.trunc()    | 去除一个数的小数部分，返回整数部分                           | 非数值, 先使用Number方法将其转为数值<br />对于空值和无法截取整数的值 ， 返回 NaN 。 |
| Math.sign()     | 判断一个数到底是正数、负数，还是零                           | 对于非数值，会先将其转换为数值。<br />正数：1<br />负数：-1<br />0: 0<br />-0：-0<br />其它值：NaN |
| Math.cbrt()     | 用于计算一个数的立方根                                       | 非数值, 先使用Number方法将其转为数值<br />                   |
| Math.clz32()    | JS 的整数使用 32 位二进制形式, <br />Math.clz32方法返回一个数的 <br />32 位无符号整数形式有多少个前导 0 | 对于小数, 只考虑整数部分。<br />对于非数值，会将它们先转为数值 |
| Math.imul()     | 两个数以 32 位带符号整数形式相乘的结果,<br />返回的也是一个 32 位的带符号整数 | 大多数情况下Math.imul(a, b) 与 a * b <br />的结果是相同的。<br />JS超过2的53次方的值无法精确表示  <br />因此这些数的乘法, 低位数值往往都是不精确的， <br />Math.imul 方法可以返回正确的**低位数值**。 |
| Math.fround()   | 返回 一个数的单精度浮点数形式                                |                                                              |
| Math.hypot()    | 返回所有参数的平方和的平方根                                 |                                                              |
| Math.expm1 (x)  | 返回 e^x-1                                                   | 与Math.exp(x) - 1等价                                        |
| Math.log1p(x)   | 返回 ln(l+x）                                                | 与Math.log(l + x ) 等价                                      |
| Math.log10(x ） | 返回以 10 为底的 x 的对数                                    | 如果 x 小于0，则返回 NaN<br />与Math.log(x) / Math.LN10等价  |
| Math.log2()     | 返回以 2 为底的 x 的对数                                     | 如果 x 小于 0 ，则返回 NaN<br />与Math.log(x) / Math.LN2等价 |

Math.trunc()示例及实现

```js
Math.trunc(4.1)  	// 4 
Math.trunc(-4.1) 	// -4 
Math.trunc(NaN)		// NaN 
Math.trunc('foo' )   // NaN 
Math.trunc()		// NaN  
```

```js
Math.trunc = Math.trunc || function(x) { 
	return x < 0? Math.ceil(x) : Math.floor(x); 
}
```

Math.sign()示例及实现

```js
Math.sign(-5) 	// -1 
Math.sign(5) 	// 1
Math.sign(O) 	// 0
Math.sign(-0) 	// -0 
Math.sign(NaN) 	// NaN 
Math.sign ('9') // 1
Math.sign ('f' ) // NaN 
Math.sign()		// NaN 
```

```js
Math.sign= Math.sign || function (x) { 
	x = +x ; // convert to a number 
	if (x === 0 || isNaN (x)) { 
		return x; 
	}
	return x > 0 ? 1 : -1; 
}
```

Math.cbrt()示例及实现

```js
Math.cbrt(-1)  // -1
Math.cbrt(2)  // 1.2599210498948734
Math.cbrt('8')  // 2
Math.cbrt('hello')  // NaN
```

```js
Math.cbrt = Math.cbrt || function(x) { 
	var y= Math.pow(Math.abs(x), 1/3) ; 
    return x < 0 ? - y : y ; 
}
```

Math.clz32()示例

```js
Math.clz32(0) 	// 32 
Math.clz32(1) 	// 31 
Math.clz32(1000) // 22 
Math.clz32 (0b01000000000000000000000000000000) // 1 
Math.clz32(3.2) 	// 30 
Math.clz32()	 	// 32 
Math.clz32(NaN) 	// 32 
Math.clz32(Infinity) // 32 
Math.clz32(null) 	// 32 
Math.clz32('foo') 	// 32 
Math.clz32([]) 		// 32 
Math.clz32({}) 		// 32 
Math.clz32(true) 	// 31
```

Math.imul()示例

```js
Math.imul(-2 , -2) // 4 
(0x7fffffff * 0x7fffffff) // O 
Math.imul(0x7fffffff, 0x7fffffff) // 1  正确
```

Math.fround() 示例及实现

```js
Math.fround( 0 ) 	// 0 
Math.fround(1) 		// 1 
Math.fround(1.337) 	// 1.3370000123977661 
Math.fround(1.5)  	// 1.5 
Math.fround(NaN) 	// NaN 
```

```js
Math.fround = Math.fround || function(x) { 
    return new Float32Array([x])[0]; 
}
```

Math.hypot() 示例及实现

```js
Math.hypot(3, 4); 		// 5
Math.hypot(3, 4, 5); 	// 7.0710678118654755
Math.hypot(); 			// 0
Math.hypot (NaN); 		// NaN 
Math.hypot(3, 4, 'foo'); // NaN 
Math.hypot(3, 4, '5'); 	 // 7.0710678118654755
Math.hypot(-3); 		// 3 
```



#### 8.7.2 双曲函数方法

ES6 新增了 6 个双曲函数方法。

- Math.sinh(x）返回 x 的双曲正弦（hyperbolic sine ) 
- Math.cosh(x）返回 x 的双曲余弦（hyperbolic cosine ) 
- Math.tanh(x）返回 x 的双曲正切（ hyperbolic tangent ) 
- Math.asinh(x）返回 x 的反双曲正弦（ inverse hyperbolic sine ) 
- Math.acosh(x ）返回 x 的反双曲余弦（ inverse hyperbolic cosine ) 
- Math.atanh(x ）返回 x 的反双曲正切（ inverse hyperbolic tangent ) 

#### 8.7.3 指数运算符

ES2016 新增了 一个指数运算符（\*\*）。

指数运算符可以与等号结合，形成一个新的赋值运算符（\*\*＝）。

在 V8 引擎中，指数运算符与 Math . pow 的实现不相同，对于特别大的运算结果，两者会有细微的差异。

```js
2 ** 2 // 4 
2 ** 3 // 8 

let a = 1.5; 
a **= 2; ／／ 等同于 a = a * a ; 
```



#### 8.7.4 Integer 数据类型

目前只是**提案**，整数类型（Integer ） 的数据只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示（包括大于2^53的数值）。

为了与 Number 类型区别， Integer 类型 的数据必须使用后缀n来表示。

- 对于 Integer 类型 的 数据 ， typeof 运算符将返回 integer 
- JavaScript 原生提供 Integer  对象，用来生成 Integer 类型的数值。转换规则基本与Number() 一致。
- 在数学运算方面 ， Integer 类型的＋、－ 、\*和\*\*这四个二元运算符与 Number 类型的行为一致。除法运算／会舍去小数部分，返回一个整数。
- Integer 类型不能与 Number 类型进行混合运算 。
- 相等运算符（==）会改变数据类型，也是不允许混合使用的。
- 精确相等运算符（===）不会改变数据类型，因此可以混合使用。

```js
1n + 2n // 3n 

// 二进制 、 八进制 、十六进制的表示法都要加上后缀 n 。
0b1101n // 二进制
0o777n  // 八进制
OxFFn   // 十六进制

typeof 12n // 'integer'

Integer(123) 	// 123n 
Integer('123')  // 123n
Integer(false) 	// 0n
Integer(true) 	// 1n

new Integer()			//	TypeError 
Integer(undefined) 		// TypeError 
Integer(null)			// TypeError 
Integer('123n') 		// SyntaxError 
Integer('abc') 			// SyntaxError 

9n / 5n 	// 1n

0n == 0 // 报错 TypeError
0n === 0 // false
```

## 9. 函数的扩展

### 9.1 函数参数的默认值

ES5设置默认值的方式

```js
function log(x, y) { 
	y = y || 'world'; 
	console.log(x, y); 
}
```

+ 缺陷 ：如果参数 y 赋值了，但是对应的布尔值为 false ，则该赋值不起作用

  ```js
  log('hello', '')  // 'hello world'
  ```

+ 解决方法：先判断一下参数 y 是否被赋值，如果没有，再令其等于默认值。

  ```js
  if (typeof y === 'undefined' ){ 
  	y = 'world'; 
  }
  ```

  

ES6设置默认值的方式

```js
function log(x , y = 'world') { 
	console.log (x, y) ; 
}

// 与解构赋值结合
function foo({x , y = 5}) { 
	console.log(x , y); 
}
foo ({}) // undefined, 5
```

- 通常情况下，定义了默认值的参数应该是函数的尾参数。因为这样比较容易看出到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是无法省略的。除非在设置默认值的位置显示传入undefined

  ```js
  function f (x = 1, y) { 
  	return [x, y]; 
  }
  f(2) 	// [2, undefined] 
  f(, 1) 	// 报错
  f(undefined, 1) // [1, 1] 
  ```

- 指定了默认值以后，函数的 l ength 属性将返回没有指定默认值的参数个数。也就是说，指定了默认值后， length 属性将失真。同理， rest 参数也不会计入 length 属性

  ```js
  (function(a) {}).length				// 1 
  (function(a= 5) {}).length 			// 0 
  (function(a, b, c = 5) {}).length 	// 2 
  (function(...args) { }).length     	// 0
  (function(a= 0, b, c) { }).length 	// 0 
  (function(a, b= 1, c) { }).length 	// 1
  ```

- 应用

  ```js
  function throwifMissing() { 
  	throw new Error ('Missing parameter') ; 
  }
  function foo (mustBeProvided = throwifMissing () ) { 
  	return mustBeProvided; 
  }
  
  foo () // Missing parameter
  ```

  

### 9.2 rest 参数

ES6 引入了 rest 参数（形式为“... 变量名")，用于获取函数的多余参数，这样就不需要使用 arguments 对象了 。 rest 参数搭配的变量是一个数组，该变量将多余的参数放入其中 。

- rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
- 函数的 length 属性不包括 rest 参数。

```js
// arguments的写法
function sortNumbers() { 
	return Array.prototype.slice.call(arguments).sort();
}
// rest参数的写法
const sortNumbers = ( ...numbers) => numbers.sort(); 

(function(a) {}).length 	 // 1 
(function(...a){}).length 	 // 0 
(function(a, ...b){}).length // 1 
```



### 9.3  严格模式

从 ES5 开始，函数内部可以设定为严格模式。

```js
function doSomething(a , b) { 
	'use strict'; 
	// code 
}
```

ES2016 做了 一点修改，规定只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则就会报错。

这样规定的原因是，函数内部的严格模式同时适用于函数体和函数参数。但是，函数执行时，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方：只有从函数体之中才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

```js
// 报错
function doSomething(value = 070) { 
	'use strict'; 
	return value ; 
}
// 参数 value 的默认值是八进制数 070 ，但是严格模式下不能用前缀。表示八进制，所以应该报错。
```

### 9.4 name 属性

函数的 name 属性返回该函数的函数名。

- 函数声明

  ```js
  function foo () { } 
  foe.name 	// 'foo'
  ```

- 函数表达式

  如果将一个匿名函数赋值给一个变量， ES5 的 name 属性会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。

  ```js
  var f = function () {};
  // ESS 
  f.name // ''
  // ES6 
  f.name // "f"
  ```

  如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的口ame 属性都返回这个具名函数原本的名字。

  ```js
  const bar = function baz () {}; 
  // ESS 
  bar.name // 'baz'
  // ES6 
  bar.name // "baz"
  ```

- 构造函数

  Function 构造函数返回的函数实例，name 属性的值为 anonymous 。

  ```js
  (new Function).name // "anonymous"
  ```

- bind

  bind 返回的函数， name 属性值会加上 bound 前缀。

  ```js
  function foo(){}；
  foo.bind({}).name // "bound foo"
  (function(){ }).bind({ }).name // "bound "
  ```

### 9.5 箭头函数

箭头函数有以下几个使用注意事项。

-  函数体内的 this 对象就是定义时所在的对象，而不是使用时所在的对象 。
- 不可以当作构造函数。 也就是说 , 不可以使用 new 命令， 否则会抛出 一个错误 。
- 不可以使用 arguments 对象 ， 该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
- 不能用 call() 、 apply ()、 bind() 这些方法去改变 this 的指向。

关于this作用域的例子

```js
function foo () { 
    setTimeout (() => { 
        console.log ('id: ', this.id) ; 
    }, 100); 
}
var id = 21; 
foo.call({ id : 42 }) ; 
// id : 42 

上面的代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义是在 foo 函数生成时生效的，而它真正执行要等到 100ms 后 。 如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是｛ id : 42 ））， 所以输出的是 42 。
```

```js
function foo() { 
	return () => { 
		return () => { 
			return () => { 
				console.log('id : ' , this.id);
            }
        }
    }
}
var f = foo.call({id: 1});
var tl = f.call({id : 2})()(); 			// id : 1 
var t2 = f().call({id: 3})(); 			// id : 1 
var t3 = f()().call({id: 4}); 			// id : 1 

上面的代码中只有一个 this ，就是函数 foo 的 this ，所以 tl, t2, t3 都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的 this ，它们的 this 其实都是最外层foo 函数的 this。
```

arguments示例

```js
function foo() { 
	setTimeout(() => { 
		console.log ('args : ', arguments) ; 
	} , 100);
}
foo(2 , 4 , 6, 8) // 'args : [2, 4, 6, 8]'

上面的代码中，箭头函数内部的变量 arguments 其实是函数 foo 的 arguments 变量。 
```

call, bind, apply 示例

```js
(function () { 
	return [ 
		(() => this. x).bind({ x ：'inner'})()
        ];
}).call({ x : 'outer' }) ; 
// ['outer'] 

上面的代码中，箭头函数没有自己的 this ，所以 bind 方法无效，内部的 this 指向外部的 this 。       
```



### 9.6 绑定this

该语法还是 ES7 的一个提案（ github.com/ zenparsing/es- function-bind ），但是 Babel 转码器已经支持。

函数绑定运算符是并排的双冒号（ :: ），双冒号左边是一个对象，右边是一个函数 。该运算符会自动将左边的对象作为上下文环境（即 this 对象）绑定到右边的函数上。

```js
foo::bar ; 
// 等同于
bar.bind(foo);

foo::bar(...arguments) ; 
// 等同于
bar.apply(foo, arguments) ; 

const hasOwnProperty = Object.prototype.hasOwnProperty ; 
function hasOwn(obj, key) { 
	return obj::hasOwnProperty(key); 
}
```

如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上 。

```js
var method = obj :: obj.foo;
// 等同于
var method= ::obj.foo ; 
```

由于双冒号运算符返回的还是原对象，因此可以采用链式写法。

```js
import { map, takeWhile, forEach } from "iterlib"; 
getPlayers()
::map(x => x.character()) 
::takeWhile(x => x.strength > 100) 
::forEach(x => console.log(x)); 
```

### 9.7 尾调用

#### 9.7.1 介绍

尾调用（ TailCall ）是函数式编程的一个重要概念，是指某个函数的最后一步是调用另一个函数。

```js
// 尾调用
function f (x) { 
	return g(x); 
}

// 不是尾调用，调用函数 q 之后还有赋值操作
function f(x) { 
	let y = g(x); 
	return y; 
}

// 不是尾调用，调用后还有操作，即使写在一行内
function f(x) { 
	return g(x) + 1 ; 
}

// 不是尾调用，这种相当于后面还有 return undefined 这一执行语句
function f(x) { 
	g(x); 
}
```

#### 9.7.2 优化

函数内调用其它函数会形成调用栈。而尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，直接用内层函数的调用帧取代外层函数的即可。

```js
function f() { 
	let m = l ; 
	let n = 2 ; 
	return g(m + n); 
}
f();

// 等同于
function f() { 
	return g(3); 
}
f(); 

// 等同于
g(3); 
```

上面的代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、 q 的调用位置等信息。但由于调用 q 之后，函数 f 就结束了，所以执行到最后一步 ， 完全可以删除 f(x)的调用帧，只保留 g (3）的调用帧 。

这就叫作“尾调用优化” （ Tail Call Optimization ），即只保留内层函数的调用帧 。 如果所有函数都是尾调用，那么完全可以做到每次执行时调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

> 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化” 。

#### 9.7.3 尾递归

函数调用自身称为递归。如果尾调用自身就称为尾递归。

递归非常耗费 内 存，因为 需要同 时保存成百上千个调用帧，很容易发生“棋世出”错误（ stack overflow ）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“枝溢出”错误 。

利用尾递归的方式阶乘优化的例子

```js
function factorial (n) { 
	if (n === 1) return 1; 
	return n * factorial(n - 1) ; 
}
factorial(5) // 120 

// 优化后
function factorial (n, total) { 
	if (n === 1) return total ; 
	return factorial(n - 1 , n *total); 
}
```

利用尾递归的方式计算 Fibonacci 数列

```js
function Fibonacci(n) { 
	if ( n <= 1 ) {return 1}; 
	return Fibonacci(n - 1) + Fibonacci(n - 2) ; 
}

// 优化后
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) { 
	if ( n <= 1 ) {return ac2} ; 
    return Fibonacci2 (n - 1 , ac2, acl + ac2); 
}
```



## 10. 数组的扩展

### 10.1 扩展运算待

扩展运算符（ spread ）是三个点（ ... ） ，将一个数组转为用逗号分隔的参数序列 。

```js
console.log(l , ...[2, 3, 4], 5) 
// 1 2 3 4 5
```

#### 10.1.1 替代apply方法

求数组的最大值

```js
// ES5
Math.max.apply(null, [14, 3, 77])
// ES6
Math.max(...[14, 3, 77])
```

合并数组

```js
// ESS 的写法
var arr1 = [0, 1, 2] ; 
var arr2 = [3, 4, 5]; 
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
var arrl = [0, 1, 2]; 
var arr2 = [3, 4, 5]; 
arrl.push(...arr2) ; 
```



#### 10.1.2 应用

合并数组

```js
// ESS 的合并数纽
arrl.concat(arr2 , arr3) ; 
// ['a', 'b', 'c', 'd'] 

// ES6 的合并数纽
[ ...arrl, ...arr2, ...arr3] 
// ['a', 'b', 'c', 'd']
```

与解构赋值结合

```js
// ESS 
a = list[0], rest = list.slice(1) 
// ES6 
[a, ...rest] = list 

const [first, ...rest] = [] ; 
first // undefined 
rest // [] 

const [ ...butLast, last]= [1 , 2 , 3 , 4 , 5] ;   // 报错
```

字符串

```js
[...'hello' ] //［ 'h'，'e'，'l'，'l'，'o' ］
```

正确识别32位字符

```js
'x\uD83D\uDE80y'.length // 4  ES5无法正确识别
[...'x\uD83D\uDE80y'].length // 3
因此使用以下的函数可以正确返回字符个数
function length(str) { 
	return [...str].length; 
}
```

#### 10.1.3 实现 Iterator 接口

任何 Iterator 接口的对象都可以用扩展运算符转为真正的数组。

```JS
var nodeList = document.querySelectorAll ('div');
var array = [ ...nodeList];
上面的代码中， querySelectorAll 方法返回的是一个 nodeList 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因在于 NodeList 对象实现了 Iterator 。
```

Map 和 Set 结构、 Generator 函数

```js
let map = new Map([ 
	[ 1, 'one'], 
	[2, 'two'], 
	[3, 'three'], 
]); 

let arr= [...map.keys()];  // [1, 2, 3] 
```

```js
var go= function*() { 
	yield l ; 
	yield 2; 
	yield 3; 
}

[...go()] // [1, 2, 3] 
```

对于没有 Ite rator 接口的对象，使用扩展运算符将会报错。

```js
var obj= {a : 1 , b: 2} ; 
let arr= [...obj]; // TypeError : Cannot spread non-iterable object
```



### 10.2 Array.from() 

Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（ array-like object ) 和可遍历（ iterable ）对象（包括 ES6 新增 的数据结构 Set 和 Map ）。

下面是一个类似数组的对象 ， Array.from 将它转为真正的数组。

```js
let arrayLike = { 
	'0': 'a', 
	'1': 'b', 
	'2': 'c', 
	length: 3
}

// ES5 的写法
var arr1 = [].slice.call(arraylike); // ['a', 'b', 'c'] 
// ES6 的写法
let arr2 = Array.from(arrayLike) ; // ['a', 'b', 'c'] 
```

实际应用中，常见的类似数组的对象是 DOM 操作返回 的 NodeList 集合，以及函数内部的arguments 对象。 Array .from 都可以将它们转为真正的数组。

```js
// NodeList 对象
let ps = document.querySelectorAll ( 'p' ) ; 
Array.from(ps).forEach(function (p) { 
	console.log (p); 
}); 

// arguments 对象
function foo () { 
	var args = Array.from(arguments);
}
```

只要是部署了 Iterator 接口的数据结构 ， Array.from 都能将其转为数组。

```js
Array.from('hi')  // ['h', 'i']

let namesSet =new Set ([ 'a', 'b'] ) 
Array.from(namesSet) // [ 'a', 'b' ] 
```

Array . from 还可以接受第**二个参数**，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

```js
Array.from(arrayLike , x => x * x) ;
// 等同于
Array.from(arrayLike).map(x => x * x ); 

Array.from([1 , , 2 , , 3), (n) => n || 0) 	// (1, 0, 2, 0, 3) 
```

所谓类似数组的对象，本质特征只有一 点 ， 即必须有 length 属性 。 因此 ，任何有 le 口 gth 属性的对象 ，都可以通过 Array.from方法转为数组

```js
Array.from({ length: 2 } , () => 'jack') 
// ['jack', 'jack'] 
```



### 10.3 Array.of() 

Array.of 方法用于将一组值转换为数组。Array.of 基本上可以用来替代 Array() 或 new Array()，井且不存在由于参数不同而导致的重载。它的行为非常统一。

```js
Array.of(3, 11, 8) 	 // [3 , 11 , 8] 
Array.of(3) 		// [3] 
Array.of() 			// [] 
Array.of(undefined)  // [undefined]

Array() // [] 
Array(3) // [ , , ,] 
Array(3, 11, 8) // [3, 11, 8] 
上面的代码中， Array 方法没有参数、有 l 个参数或有 3 个参数时，返回结果都不一样。只有当参数个数不少于 2 个时, Array() 才会返回由参数组成的新数组。参数个数只有1个时，实际上是指定数组的长度。
```

ES5实现

```js
function ArrayOf() { 
	return [].slice.call(arguments); 
}
```

### 10.4 copyWithin()

数组实例的 copyWithin 方法会在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法会修改当前数组。

Array.prototype.copyWithin(target, start= 0 , end= this.length) 

- target (必选)) ：从该位置开始替换数据。
- start (可选) ：从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。
- end(可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

```js
[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3 , 4, 5]
上面的代码表示，将从 3 号位置直到数组结束的成员（ 4 和 5 ）复制到从 0 号位置开始的位置，结果覆盖了原来的 1 和 2 。

[1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4 , 2, 3, 4, 5]
```

### 10.5 find() 和 findIndex() 

 find ：找出**第一个**符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数 ， 直到找出第一个返回值为 true 的成员，然后返回该成员 。如果没有符合条件的成员，则返回 undefined 。

```js
[1, 5, 10, 15].find (function (value, index, arr) { 
	return value > 9; 
} 	// 10 
```

findIndex： 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 。

```js
[1, 5, 10, 15].findIndex (function (value, index, arr) {
    return value > 9; 
}) // 2
```

这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象 。

### 10.6 fill()

fill 方法使用给定值填充一个数组。

```js
['a', 'b', 'c'].fill(7)  	// [7, 7, 7]
new Array (3).fill(7) 		// [7, 7, 7]
```

fill 方法还可以接受第二个和第三个参数 ， 用于指定填充 的起始位置和结束位置 。

```js
['a', 'b', 'c'].fill(7, 1, 2) 	// ['a', 7, 'c'] 
```

### 10.7 entries(), keys() 和 values()

 keys() ：是对键名的遍历

values() ：是对键值的遍历

entries()：是对键值对的遍历

```js
for (let elem of [ 'a', 'b'].keys()) { 
	console.log(elem) ; 
}	
// 0 
// 1

for (let [index , elem] of [ 'a', 'b'].entries() ) { 
	console.log(index, elem) ; 
}
// 0 "a"
// 1 "b" 
```

### 10.8 includes()

Array.prototype.includes() 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。 

```js
[1, 2, 3].includes(2) 	// true
[1, 2, 3].includes(4) 	// false 
[1, 2, NaN].includes(NaN) // true 
```

该方法的第二个参数表示搜索的起始位置 ， 默认为 0 。如果第二个参数为负数 ，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为－4 ， 但数组长度为 3 ），则会重置为从0 开始。

```js
[1, 2, 3].includes(3, 3) ; 	// false 
[1, 2, 3].includes(3, -1); 	// true 
```

没有该方法之前，我们通常使用数组的 indexOf 方法检查是否包含某个值。indexOf 方法有两个缺点 ： 一是不够语义化，其含义是找到参数值的第一个出现位置，所以要比较是否不等于－ 1 ，表达起来不够直观：二是，其内部使用严格相等运算符（===）进行判断，会导致对 NaN 的误判。

兼容不支持的环境

```js
const contains = (() => Array.prototype.includes 
	? (arr, value) => arr.includes(value) : (arr, value) => arr.some(el => el=== value) 
)(); 
```

### 10.9 数组的空位

数组的空位指数组的某一个位置没有任何值。比如， Array 构造函数返回的数组都是空位 。

```js
Array(3) // [,,,] 一个具有 3 个空位的数组。
```

> 空位不是 undefined ，一个位直的值等于 undefined 依然是有值的 。 空位是没有任何值的， in 运算符可以说明这一点 。

```js
0 in [undefined, undefined, undefined] // true 
0 in [,,,] 			// false 
上面的代码说明，第一个数组的 0 号位置是有值的 ， 第二个数组的 0 号位置没有值。
```

ES5 对空位的处理很不一致 ，大多数情况下会忽略空位 。

- forEach()、filter()、every() 和 some()都会跳过空位。
- map() 会跳过空位，但会保留这个值。
- join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串。

```js
// filter 方法
['a',, 'b'].filter (x => true) 	// ['a', 'b'] 

// every 方法
[, 'a'].every (x => x=== 'a') 		// true 

// some 方 法
[, 'a'].some (x => x !== 'a') 		// false 

// map 方法
[,'a'].map(x => 1)		 // [, 1] 

// join 方法
[,'a', undefined, null].join( '#')		// '#a##' 

// toString 方法
[, 'a', undefined, null].toString() 	//", a ,," 
```

ES6 则是明确将空位转为 undefined 。

Array.from 方法会将数组的 空位转为 undefined. 也就是说，这个方法不会忽略空位。

```js
Array.from(['a',,'b']) 	// ['a', undefined, 'b'] 
```

扩展运算符（ ... ）也会将空位转为 undefined .

```js
[...['a',,'b']] 	// ['a', undefined, 'b'] 
```

copyWithin() 会连空位一起复制。

```js
[,'a','b',,].copyWithin(2,0) // [,'a',,'a'] 
```

fill()会将空位视为正常的数组位置。

```js
new Array(3).fill('a') // ['a', 'a', 'a'] 
```

for ... of 循环也会遍历空位 。

entries()、 keys() 、 values() 、find() 和 findindex() 会将空位处理成 undefined 。

```js
[...[,'a'].values()) 	// [undefined,'a'] 
```

由于空位的处理规则非常不统一 ，所以建议避免出现空位。



## 11. 对象的扩展

### 11.1 属性简写

ES6 允许在对象中只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。

注意，简洁写法中属性名总是字符串。

```js
var foo ='bar'; 
var baz = {foo};  // 等价于 var baz = {foo: foo}
baz // {foo : 'bar' } 
```

方法简写

```js
var o = {
	method() {
		return "Hello!";
    }
}
// 等价于
var o = {
	method: function() {
		return "Hello!";
    }
}
```

CommonJS利用这种写法非常方便

```js
module.exports = { getitem, setitem, clear }; 
// 等同于
module.exports = { 
	getitem : getitem, 
	setitem : setitem, 
	clear : clear
}
```

属性的赋值器（ setter ）和取值器（ getter ） 事实上也采用了这种写法。

```js
var cart = { 
	wheels: 4, 
	get wheels () { 
		return this.wheels; 
    }
	set wheels(value) { 
		if (value < this.wheels) { 
			throw new Error('数值太小了')；
		}
    	this.wheels = value; 
	}
}
```

如果某个方法的值是一个 Generator 函数，则其前面需要加上星号 。

```js
var obj = { 
	* m() { 
		yield 'hello world';
	}
}
```

由于简写的方法是字符串，所以以下的代码也正确

```js
var obj = { 
	class () {} 
};
```

### 11.2 属性名表达式

JavaScript 语言定义对象的属性有两种方法。

```js
// 方法一
obj.foo =true;

// 方法二
obj ['a' + 'b'] = 123; 
```

但是，如果使用字面量方式定义对象（使用大括号），则在 ES5 中只能使用方法一 （标识符）定义属性。

```js
var obj = { 
	foo : true, 
	abc: 123 
}
```

ES6 允许字面量定义对象时用方法二 （表达式作为对象的属性名)，即 把表达式放在方括号内。

```js
let propKey = 'foo' ; 
let obj ={
	[propKey] : true, 
	['a' + 'bc'] : 123 
}
```

表达式还可以用于定义方法名 。

```js
let obj = { 
	[ 'h' + 'ello' ](){ 
		return 'hi' ;
    }
}
obj.hello()  // hi 
```

注意 ， 属性名表达式与简洁表示法不能同 时使用， 否则会报错。

```js
var foo＝'bar' ; 
var bar = 'abc'; 
var baz = { [foo] } ;  // 报错
var baz = { [foo] : 'abc' }; // 正确 
```

注意属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串［object Object ，这一点要特别小心。

```js
const keyA = {a: 1}; 
const keyB = {b: 2}; 
const myObject = { 
	[keyA]: 'valueA', 
	[keyB]: 'valueB', 
}
myObject // Object {[object Object]: "valueB"} 
上面的代码中，［keyA]和［keyB］得到的都是［object Object]，所以［keyB］会把 [keyA］覆盖掉，而 myObject 最后只有一个［object Object]属性。
```

### 11.3 方法的 name 属性

函数的 name 属性返回函数名。对象方法也是函数，因此也有 name 属性。

```js
const person = { 
	sayName() { 
		console.log ('hello !');
	}
}
person.sayName.name // "sayName" 
```

如果对象的方法使用了取值函数（ getter ）和存值函数（ setter ），则 name 属性不是在该方法上面，而是在该方法属性的描述对象的 get 和 set 属性上面，返回值是方法名前加上get 和 set 。

```js
const obj = { 
	get foo () {}, 
	set foo (x) {}
}
obj.foo.name // TypeError: Cannot read property 'name' of undefined 
const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo')

descriptor.get.name 	// "get foo"
descriptor.set.name 	// "set foo
```

有两种特殊情况：

-  bind 方法创造的函数， name 属性返回“ bound ”加上原函数的名字：
- Function 构造函数创造的函数， name 属性返回“ anonymous ”

```js
(new Function()).name // "anonymous"
var doSomething = function() { 
	// 
}
doSomething.bind().name // "bound doSomething"
```

如果对象的方法是一个 Symbol 值，那么 name 属性返回的是这个 Symbol 值的描述。

```js
const keyl = Symbol('description'); 
const key2 = Symbol(); 
let obj = { 
	[key1]() {} , 
	[key2]() {}, 
}
obj[key1].name // "[description]"
obj[key2].name // ""
```



### 11.4 Object.is() 

'==' ：会自动进行类型转换

‘===’：NaN不等于自己、+0等于-0

Object.is()类似于‘===’ ，不同之处只有两个 ： 一是+0 不等于-0 ， 二是 NaN 等于自身。

```js
Object.defineProperty(Object，'is'， ｛
	value : function (x , y) { 
		if (x === y) { 
		// 针对＋0 不等于－0 的情况
			return x !== 0 || 1/x === 1/y;
        }
		// 针对 NaN 的情况  自己不等于自己是NaN
		return x !== x && y !== y; 
	} , 
	configurable : true , 
	enumerable: false , 
	writable : true 
}); 
```

### 10.5 Object.assign() 

#### 10.5.1 基本用法

Object.assign 方法用于将源对象（ source ）的所有可枚举属性复制到目标对象（ target ）。

Object.assign 方法的第一个参数是目标对象 ， 后面 的参数都是源对象 。

```js
var target= { a : 1 }; 
var sourcel = { b : 2 }; 
var source2 = { c : 3 }; 
Object.assign(target, source1, source2); 
target // {a : 1 , b : 2 , c : 3} 
```

如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的 属性。

```js
var target = { a: 1, b: 1 } ; 
var sourcel = { b : 2, c : 2 }; 
var source2 = { c : 3 }; 

Object.assign(target, sourcel, source2) ; 
target // {a:1, b:2, c:3} 
```

如果只有一个参数， Object.assign 会直接返回该参数。

```js
var obj = {a: 1} ; 
Object.assign(obj) === obj // true 
```

如果该参数不是对象， 则会先转成对象，然后返回。

由于 undefined 和 null 无法转成对象 ，所以如果将它们作为参数 ， 就会报错 。

```js
typeof Object.assign(2) // "object"
Object.assign(undefined) // 报错
Object.assign(null)  // 报错
```

如果非对象参数出现在源对象的位置（即非首参数），那么处理规则将有所不同。首先，这些参数都会转成对象，如果无法转成对象便会跳过 。这意味着，如果 undefined 和 null 不在首参数便不会报错。

```js
let obj = {a : 1} ; 
Object.assign(obj, undefined) ===obj // true 
Object.assign （obj, null) === obj // true 
```

其他类型的值（即数值、字符串和布尔值）不在首参数也不会报错 。 但是，除了字符串会以数组形式复制到目标对象，其他值都不会产生效果。

```js
var vl = 'abc'; 
var v2 = true ; 
var v3 = 10; 
var obj= Object.assign({} , vl, v2 , v3 ) ; 
console.log (obj ); // ｛'0'：'a' ，'1'：'b'，'2:'c ｝
```

属性名为 Symbol 值的属性也会被 Object . assign 复制。

```js
Object.assign ( { a ：'b'}, { [Symbol('c')] : 'd' }) 

// { a ：'b', [Symbol('c')] : 'd'}
```

### 

#### 10.5.2 注意点

Object . assi gn 方法实行 的是浅复制，而不是深复制。也就是说，如果源对象某个属性的值是对象，那么目标对象复制得到的是这个对象的引用。

一旦遇到同名属性， Object.assign 的处理方法是替换而不是添加。

注意， Object . assign 可以用来处理数组，但是会把数组视为对象来处理。

```js
Object.assign([1, 2, 3 ], (4, 5) ) 
// [4, 5, 3]
```



#### 10.5.3 用途

为对象添加属性

```js
class Point { 
	constructor(x, y) { 
		Object.assign(this, {x, y}); 
    }
}
上面的方法通过 assign 方法将 x 属性和 y 属性添加到了 Point 类的对象实例中。
```

为对象添加方法

```js
Object.assign(SomeClass.prototype, { 
	someMethod (argl, arg2) { 
        ...
    },
    anotherMethod () {
         ...   
    }
})
```

克隆对象

```js
function clone(origin) { 
	return Object.assign({}, origin); 
}
不过，采用这种方法只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。
function clone(origin) { 
	let originProto = Object.getPrototypeOf ( origin );
	return Object.assign(Object.create(originProto), origin ); 
}
```

合并多个对象

```js
将多个对象合并到某个对象。
const merge = (target , ... sources) => Object.assign(target,...sources); 
如果希望合并后返回 一个新对象，可以改写上面的函数，对一个空对象合并。
const merge = (...sources) => Object.assign ( {}, ...sources);
```

为属性指定默认值

```js
const DEFAULTS = { 
	logLevel: 0, 
	outputFormat : 'html'
}

function processContent(options) { 
	options= Object.assign({} , DEFAULTS, options); 
	console.log(options); 
}
```

> 由于存在深复制的问题， DEFAULTS 对象和 options 对象的所有属性的值都只能是简单类型，而不能指向另一个对象，否则将导致 DEFAULTS 对象的该属性不起作 用 。

```js
const DEFAULTS = { 
	url : { 
		host : 'example.com', 
		port : 7070 
    }
}
processContent ( { url: {port : 8000} } ) 
//{ 
// 	url: {port: 8000) 
//}
```

### 10.6 属性的可枚举性

Object.getOwnPropertyDescriptor 方法可以获取对象某一属性的描述对象。包括`value`, `wirteable`, `enumerable`,`configurable`

ESS 有 3 个操作会忽略 enumerable 为 false 的属性。

- for ... in 循环：只遍历对象自身的和继承的可枚举属性。
- Object.keys()：返回对象自身的所有可枚举属性的键名 。
- JSON.stringify()：只串行化对象自身的可枚举属性。

ES6 规定，所有 Class 的原型的方法都是不可枚举的。

```js
Object.getOwnPropertyDescriptor (class {foo() {}}.prototype,'foo').enumerable // false
```





### 10.7 属性的遍历

ES6 一共有 5 种方法可以遍历对象的属性 。

1. for...in ：对象自身的和继承的可枚举属性（不含 Symbol 属性）。
2. Object.keys(obj) ：自身的（不含继承的 ）所有可枚举属性（不含 Symbol 属性）。
3. Object.getOwnPropertyNames(obj)：自身的所有属性（不含 Symbol属性，但是包括不可枚举属性）。
4. Object.getOwnPropertySymbols(obj)：自身的所有 Symbol 属性。
5. Reflect.ownKeys (obj)：包含对象自身的所有属性 ，不管属性名是 Symbol 还是字符串，也不管是否可枚举。

以上 5 种方法遍历对象的属性时都遵守同样的属性遍历次序规则 。

- 首先遍历所有属性名为数值的属性 ， 按照数字排序 。
- 其次遍历所有属性名为字符串的属性，按照生成时间排序。
- 最后遍历所有属性名为 Symbol 值的属性 ， 按照生成时间排序。

### 10.8  \_\_proto\_\_

\__proto\_\_属性（前后各两个下画线）用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。也写入了ES6的附录

```js
// ES6 的 写法
var obj = {
    method: function(){...}
} 
obj.__proto__ = someOtherObj;

// ES5 的写法
var obj = Object.create(someOtherObj) ; 
obj.method = function () {...} ; 
```

无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，推荐使用 Object.setPrototypeOf ( ) （写操作）、 Object.getPrototypeOf () （读操作）或 Object.create () （生成操作）代替__proto__。



### 10.9 Object .setPrototypeOf()

Object . setPrototypeOf 方法的作用与 \__proto\_\_相同，用来设置 一 个对象的prototype 对象，返回参数对象本身 。 它是 ES6 正式推荐的设置原型对象的方法。

语法

```js
Object.setPrototypeOf(object, prototype) 
```

等价于

```js
function (obj, proto) { 
	obj._proto_ = proto; 
	return obj; 
}
```

示例

```js
var o = Object.setPrototypeOf({} , null) ; 
```

如果第一个参数不是对象，则会自动转为对象。由于 undefined 和 null 无法转为对象，所以如果第一个参数是 undefined 或 null 就会报错。



### 10.10 Object .getPrototypeOf() 

该方法与 setPrototypeOf 方法配套，用于读取一个对象的 prototype 对象 。

语法

```js
Object.getPrototypeOf(obj); 
```

如果参数不是对象，则会被自动转为对象。如果参数是 undefined 或 null ，它们无法转为对象，所以会报错。

### 10.11 entries(), keys() 和 values()

Object.keys() : 返回 一个数组，成员是参数对象自身的（不含继承的）所有可遍历 ( enumerable ）属性的键名。

Object.keys() : 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历 ( enumerable ）属性的键值。

Object.entries() : 返回一个数组 ，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键值对数组。

以上方法均过滤属性名为Symbol类型的键值对。

Object.entries()用途：

1. 遍历对象的属性 。

   ```js
   for (let [k, v] of Object.entries(obj)) { 
       // ...
   }
   ```

2. 将对象转为真正的 Map 结构

   ```js
   var obj = { foo : 'bar', baz: 42 ) ; 
   var map= new Map(Object.entries(obj)); 
   map // Map { foo : "bar", baz : 42 ) 
   ```

   

### 10.12 对象的扩展运算待

ES2017 将运算符（...）引入了对象。

```js
let { x , y, ...z } = { x : 1, y : 2, a: 3 , b : 4 }; 
z // {a: 3, b: 4 }
```

注意：

1. 由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null 就会报错 ， 因为它们无法转为对象。
2. 解构赋值必须是最后一个参数，否则会报错 。
3. 解构赋值的复制是浅复制， 如果一个键的值是复合类型的位（数组、对象、函数），那么解构赋值复制的是这个值的引用，而不是这个值的副本。
4. 解构赋值不会复制继承自原型对象的属性。

```js
ar o =Object.create({ x : 1 , y : 2 }); 
o.z = 3 ; 

let { x , ... { y , z } } = o ; 
x // 1 
y // undefined 
z // 3 
变量 y 和 z 是双重解构赋值，只能读取对象。自身的属性，所以只有变量 z 可以赋值成功 。
```

作用

1. 扩展某个函数的参数，引入其他操作。

   ```js
   function wrapperFunction({ x, y , ...restConfig }) { 
   }
   ```

2. 取出参数对象的所有可遍历属性，并将其复制到当前对象之中。这等同于使用 Object.assign 方法。

   ```js
   let z = { a : 3 , b : 4 } ; 
   let n = { ...z } ; 
   n // { a : 3 , b: 4 } 
   
   // 等同于
   let aClone =Object.assign({}, a); 
   ```

3. 合井两个对象

   ```js
   let ab= { ...a, ...b }; 
   // 等同于
   let ab= Object.assign({}, a , b) ; 
   ```

### 10.13 Object.getOwnPropertyDescriptor() 

Object.getOwnPropertyDescriptor 方法可以获取对象某一属性的描述对象。包括`value`, `wirteable`, `enumerable`,`configurable`

## 11. Set和Map

### 11.1 Set

#### 11.1.1 基本介绍

- Set类似于数组，但是成员的值都是唯一的，没有重复的值。
- Set使用add()方法添加元素，不会添加重复的值，所以Set可以对数组进行去重操作。
- Set对象的长度用size属性获取。
- 向 Set 加入值时不会发生类型转换，类似于精确相等运算符(===)，主要的区别是Set对象中 NaN 等于自身。
- 向Set添加两个对象总是不相等的 。

```js
let set= new Set(); 
let a = NaN ; 
let b = NaN ; 
set.add(a); 
set.add (b); 
set 			// Set {NaN}

let set= new Set() ; 
set.add({}) ; 
set.size 		// 1 
set.add({}); 
set.size 		// 2 
```

#### 11.1.2 操作方法

Set的四个操作方法：

1. add (value）：添加某个值，返回 Set 结构本身。
2. delete(value）：删除某个值，返回一个布尔值，表示删除是否成功。
3. has (value）：返回 一个布尔值，表示参数是否为 Set 的成员。
4. clear() ： 清除所有成员，没有返回值。

- Map类似于对象，键名的值可以是各种类型的值。

#### 11.1.3 遍历方法

Set 结构的实例有 4 个遍历方法，可用于遍历成员 。遍历顺序：插入顺序。

1. keys() ： 返回键名的遍历器。由于Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。
2. values() ：返回键值的遍历器 。
3. entries() ：返回键值对的遍历器 。
4. forEach() ：使用回调函数遍历每个成员 。(也可以使用for ... of 循环遍历 Set)

```js
let set = new Set (['red', 'green', 'blue']); 
for (let i item of set.keys()) { 
	console.log(item); 
}

// red 
// green 
// blue 
```

#### 11.1.4 应用

求并集

```js
function union(a, b) {
    return Array.from(new Set([...a, ...b]));
}
```

求交集

```js
function intersect(a, b) {
    return Array.from(new Set([...a].filter(x => b.has(x))));
}
```

求差集

```js
function difference(a, b) {
    return Array.from(new Set([...a].filter(x => !b.has(x))));
}
```



#### 11.1.4 转数组

Array.from 方法可以将 Set 结构转为数组。

```js
const items= new Set([1, 2, 3, 4, 5]); 
const array= Array.from(items) ; 
```

这就提供了一个数组去重的方式

```js
function dedupe(array) { 
	return Array.from(new Set(array)); 
}
```



### 11.2 WeakSet

#### 11.2.1 基本介绍
WeakSet结构与Set类似，也是不重复的集合。但是，它与Set有两个区别。
1. WeakSet的成员只能是对象，不能是其它类型的值（包括Symbol）
2. WeakSet中的对象都是弱引用，即垃坡回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还存在于 WeakSet 之中 。
由于上面这个特点， WeakSet 的成员是不适合引用的，因为它会随时消失 。另外， WeakSet内部有多少个成员取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。

语法：

WeakSet 是一个构造函数，可以使用 new 命令创建 WeakSet 数据结构 。
```js
// 不带参数
const ws ＝new WeakSet(); 
// 带参数
const ws ＝new WeakSet(obj); 
```
带参数创建WeakSet对象时，改参数（一般为数组或类似数组的对象）的所有成员都会自动成为WeakSet实例对象的成员。而由于WeakSet的成员只能是对象，这意味着，数组的成员只能是对象。
```js
const a = [[1 , 2], [3 , 4]]; 
const ws =new WeakSet(a) ; 
// WeakSet {[1 , 2], [3 , 4]} 

const b = [3 , 4]; 
const ws = new WeakSet(b); 
// Uncaught TypeError: Invalid value used in weak set(... ) 
```

#### 11.2.2 操作方法
WeakSet 结构有以下 3 个方法。
- WeakSet.prototype.add(value)： 向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value)： 清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value)： 返回一个布尔值，表示某个值是否在 WeakSet 实例中。

```js
const ws =new WeakSet() ; 
const obj = {} ; 
const foo = {} ; 

ws.add(window); 
ws.add(obj) ; 

ws.has(window);   // true 
ws.has(foo);      // false 

ws.delete(window); 
ws.has(window) ; // false 
```
#### 11.2.3 不可遍历

WeakSet内部有多少个成员取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。因此WeakSet也没有size属性。

#### 11.2.4 应用
WeakSet 的 一个用处是储存 DOM 节点，而不用担心这些节点从文档移除时会引发内存泄漏。
下面是 WeakSet 的另一个例子。
```js
const foos =new WeakSet() 
class Foo { 
  constructor() { 
    foos.add (this) 
  }
  method () { 
    if (!foos.has(this)) { 
      throw new TypeError('Foo.prototype.method 只能在 Foo 的实例上调用') ; 
    }
  }
}
```
上面的代码保证了 Foo 的实例方法只能在 Foo 的实例上调用。这里使用 WeakSet 的好处是，数组 foos 对实例的引用不会被计入内存回收机制，所以删除实例的时候不用考虑 foos, 也不会出现内存泄漏。




### 11.3 Map
#### 11.3.1 基本介绍
JavaScript 的对象（Object）本质上是键值对的集合（Hash结构），但是只能用字符串作为键。这给它的使用带来了很大的限制。

ES6 提供了 Map 数据结构。它类似于对象 ，也是键值对的集合，但是
“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 

> 只有对同一个对象的引用， Map 结构才将其视为同一个键。 这一点要非常小心。
```js
const map= new Map(); 
map.set (['a'], 555); 
map.get ( ['a']) // undefined 

上面的 set 和 get 方法表面上是针对同一个键，实际上却是两个值，内存地址是不一样的，因此 get 方法无法读取该键，返回 undefined 。
```
由上可知， Map 的键实际上是和内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（ clash ）的问题，我们扩展别人的库时，如果使用对象作为键名，不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 就将其视为一个键，包括 0 和-0 。另外，虽然 NaN 不严格等于自身，但 Map 将其视为同一个键。

#### 11.3.2 操作方法

- size 属性：返回 Map 结构的成员总数。
- set(key, value) ：设置 key 所对应的键值，然后返回整个 Map 结构。如果 key 己经有值，则键值会被更新，否则就新生成该键。set 方法返回的是当前的 Map 对象，因此可以采用链式写法。
- get(key) ：读取 key 对应的键值，如果找不到 key，则返回 undefined。
- has(key) ：返回一个布尔值，表示某个键是否在 Map 数据结构中。
- delete( key) ：删除某个键，返回 true 。如果删除失败，则返回 false 。
- clear() ：clear 方法清除所有成员，没有返回值。
#### 11.3.3 遍历方法
Map 原生提供了 3 个遍历器生成函数和 l 个遍历方法 。
- keys()：返回键名的遍历器。
- values()：返回键值的遍历器。
- entries()：返回所有成员的遍历器。
- forEach()：遍历 Map 的所有成员。
需要特别注意 的是， Map 的遍历顺序就是插入顺序 。
```js
const map= new Map([ 
  ['F', 'no'] , 
  ['T', 'yes'] , 
]);

for (let item of map.entries()) { 
  console.log(item[0] , item[1]) ; 
}

// "F" "no"
// "T" "yes"
```
#### 11.3.4 Map转数组
Map 转为数组最方便的方法就是使用扩展运算符（...）
```js
const myMap = new Map()
    .set (true, 7) 
    .set ({foo : 3} , ['abc']); 
[...myMap]
// [[true, 7], [{foo: 3},['abc]]]    
```
#### 11.3.5 数组转Map
将数组传入 Map 构造函数就可以转为 Map。
```js
new Map ([ 
  [true, 7], 
  [(foo : 3), ['abc']] 
]) 
// Map {
//  true => 7,
//  Object {foo: 3} => ['abc']  
//}
```
#### 11.3.6 Map转对象
如果 Map 的所有键都是字符串，则可以转为对象 。
```js
function strMapToObj (strMap) { 
  let obj= Object.create(null) ; 
  for (let [k, v] of strMap ) { 
    obj [k] = v ; 
  }
  return obj;
}
```

#### 11.3.7 对象转Map
```js
functi on objToStrMap (obj) { 
  let strMap =new Map (); 
  for (let k of Object.keys(obj)) { 
    strMap.set(k, obj[k]);
  }
  return strMap;
} 
```
Map转JSON
Map 转为 JSON 要区分两种情况 。
- 一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON 。
  ```js
  function strMapToJson(strMap) { 
    return JSON.stringify(strMapToObj(strMap));
  }
  ```
- 另一种情况是， Map 的键名有非字符串，这时可以选择转为数组 JSON 。
  ```js
  function mapToArrayJson(map) { 
    return JSON.stringify([...map]); 
  ```
#### 11.3.8 JSON转Map
JSON 转为 Map ，正常情况下所有键名都是字符串。
```js
function jsonToStrMap(jsonStr) { 
  return objToStrMap (JSON.parse(jsonStr)); 
}
```



### 11.4 WeakMap
#### 11.4.1 基本介绍
WeakMap 结构与 Map 结构类似 ，也用 于生成键值对的集合。与 Map 的区别有以下两点
1. WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。
2. WeakMap 的键名所指向的对象不计入垃圾回收机制。


> WeakMap弱引用的只是键名而不是键值。键值依然是正常引用的。

#### 11.4.2 操作方法
WeakMap只有4个方法可用： get()、set()、has()、delete() 。

size、forEach、clear 方法都不存在

#### 11.4.4 应用
1.  DOM 节点作为键名的场景
    ```js
    const el = document.getElementByid ( 'foo' ) ; 
    const e2 = document.getElementByid ( 'bar' ) ; 
    const arr = [ 
        [el, 'foo元素'],
        [e2, 'bar元素'],
    ]
    ```
    上面的代码中，el 和 e2 是两个对象， 我们通过 arr 数组对这两个对象添加一些文字说明，这就形成了 arr 对 el 和 e2 的引用。 
    一旦不再需要这两个对象，我们必须手动删除这个引用，否则垃圾回收机制就不会释放 el和 e2 占用的内存。
    ```js
    arr [0] = null; 
    arr [1] = null; 
    ```
    上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄漏。

    WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除， 垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，Weak.Map 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

    基本上，如果要向对象中添加数据又不想干扰垃圾回收机制，便可以使用 WeakMap 。一个典型应用场景是，在网页的 DOM 元素上添加数据时就可以使用 WeakMap 结构 。当该 DOM 元素被清除，其所对应的WeakMap 记录就会自动被移除 。

    ```js
    const wm ＝new WeakMap() ; 
    const element = document.getElementByid ('example') ; 
    wm.set(element, 'some information'); 
    wm.get(element)    // "some information" 
    ```

    上面的代码中首先新建了一个 WeakMap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值一起存放在WeakMap里面 。 这时，WeakMap 里面对 element 的引用就是弱引用， 不会被计入垃圾回收机制。
    上面的 DOM 节点对象的引用计数是1 ，而不是2 。这时, 一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。 WeakMap 保存的这个键值对也会自动消失。
2. 注册监昕事件的 listener 对象很适合用 WeakMap 来实现。
    ```js
    const listener= new WeakMap(); 
    listener.set(elementl, handlerl) ; 
    listener.set(element2, handler2) ; 
    elementl.addEventListener ('click', l istener.get(elementl), false) ; 
    element2.addEventListener ('click', listener.get(element2), false) ; 
    ```
    上面的代码中，监听函数放在 WeakMap 里面。 一旦 DOM 对象消失，与它绑定的监昕函数也会自动消失。

3. WeakMap 的另一个用处是部署私有属性。
    ```js
    const _counter= new WeakMap() ; 
    const _action= new WeakMap() ; 

    class Countdown {
      constructor(counter, action) { 
        _counter.set(this, counter); 
        _action.set (this, action);
      } 
      dec() {
        let counter= counter.get(this); 
        if (counter < 1) return ; 
        counter--; 
        _counter.set(this, counter) ; 
        if (counter === 0) {
          _action.get(this) (); 
        }
      }
    }
    const c = new Countdown (2, () => console.log ('DONE'));c.dec() 
    c.dee() 
    ```
    上面的代码中， Countdown 类的两个内部属性_counter 和 _action是实例的弱引用，如果删除实例，它们也会随之消失，不会造成内存泄漏。
